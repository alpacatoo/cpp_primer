# 类

- 类的基本思想：通过定义一个抽象数据类型，实现数据抽象和封装
- 数据抽象是一种依赖于接口和实现分离的编程技术



## 定义抽象数据类型

### 定义类类型

- 定义在类内部的函数时**隐式的inline函数**
- 定义成员函数
  - 成员函数可以定义在类内，也可以定义在类外
  - 类内的函数定义与一般函数一样
  - 编译器处理类的步骤：（1）编译成员声明；（2）编译成员函数体
  - 因此成员函数体随意使用类中其他成员，**无需在意这些成员出现的顺序**
  - 类内声明函数，类外定义函数时，类外定义的函数名字前需要加上类作用域：`类目::函数名`

### 引入**this**指针

- 调用类的成员函数，就是替某个对象调用；
- 如果成员函数使用类的成员，则成员函数**隐式地**指向调用该函数的对象的成员
- 成员函数通过**this**的额外的隐式参数来访问调用它的那个对象
- 在成员函数内部，**不需要成员访问运算符**，任何对类成员的访问都被看作this的隐式引用
- **this时一个常量指针**

### 引入`cosnt`成员函数

- 紧随参数列表止之后的`const`关键字，会修改隐式`this`指针的类型
- 默认情况：`this`指向类类型**非常量**版本的常量指针,即`Sales_data *const`，不能绑定到常量对象
- 紧随参数列表之后的`cosnt`，将`this`指针指向常量对象的常量指针，即`const Sales_date *const`
- 使用`cosnt`的成员函数称为**常量成员函数**，`this`是常量指针，在函数内不能改变对象的内容
- **常量对象以及常量对象的引用或指针只能调用常量成员函数**

- 函数被声明为常量成员函数，则定义也需要子啊参数列表后名且指出`const`属性

### 返回this对象的函数

- 返回类型是类类型的引用，`return`语句返回`*this`

### 定义类相关的非成员函数

- 有些函数是类接口的一部分，但不属于类本身
- 一般跟**类声明**在同一个头文件里
- **IO类属于不可被拷贝类型**，只能使用引用
- 输出任务的函数尽量减少对格式的控制
- 拷贝类的对象其实拷贝的是类对象的数据成员。

### 构造函数

- 构造函数：类通过一个或几个特殊的成员函数来控制其对象的初始化过程
- 构造函数名与类名一样；不同构造函数要在参数数量或参数类型上有所区别；构造函数不能被声明成`const`
- 默认构造函数：对象初始化没有初始值，无需任何实参
- 合成的默认构造函数：编译器创建的构造函数；有类内初始值，用它初始化对象；否则默认初始化。
- **必须定义自己的默认构造函数**的原因：
  - 编译器只会在发现**没有任何构造函数**情况下才合成默认构造函数；所以自己必须定义默认构造函数
  - **合成的默认构造函数**可能指向错误操作
  - 编译器不能为某些类合成默认构造函数
- 编译器生成构造函数
  - 在参数列表后面写上`= default`
  - 既可以和声明一起在类内，也可以作为定义出现在类外
  - 类内部内联；外部不是内联
- 构造函数初始值列表

### 拷贝、赋值和析构

- 对象拷贝的情况
  - 初始化变量
  - 以值的凡是传递
  - 返回一个对象
  - 赋值操作符
- 这些操作可以编译器生产；生产的版本将对对象的每个成员指向拷贝、赋值和销毁
- 类的合成版本失效的情况：当类需要分配类对象之外的资源时
- 使用`vercor`和`string`的类能避免分配和释放内存带来的复杂性；即类包含`vector`或`string`成员，则其拷贝、赋值和销毁的合成版本能够正常功能。



## 访问控制与封装 

- 访问说明符：
  - **public**：成员整个程序都可访问，定义接口
  - **private**：成员被类的成员函数访问，不能被使用该类的代码访问
- 一个类可以包含0个或多个访问说明符，访问范围直到下一个访问说明符或者类结尾处
- **class**默认访问权限为**private**；**struct**默认访问权限为**public**

### 友元

- 友元函数：类内增加一条以**friend**关键字开头的声明，使得其他类或函数可以访问它的**非公有成员**。
- 友元函数声明只能出现在类的内部；**仅仅指定了访问权限**；为了调用函数的函数声明需要单独再进行一次。
- 友元声明与类本身放在一起



## 类成员再探

- 除定义成员变量和成员函数，类还可以自定义某种类型在类中的别名
- 类型中别名同意具有访问限制
- 声明类中别名的注意事项
  - 可以用`typedef`声明，也可以用类型别名`using`声明
  - 用该别名定义的成员必须向定义，后使用。**（普通成员只要在类的作用域中即可）**
- 成员函数作为内联函数
  - 函数定义在类内：隐式的内联
  - 函数声明在类内，并使用**inline**关键字：显式的内联
  - 函数声明在类内，未使用**inline**关键字，类外定义时使用**inline**关键字：显示的内联
  - **（只要声明或定义时存在一处inline关键字，则为显示的内联；建议在类外定义时使用）**
- 可变数据成员：const成员函数中修改某个数据成员，该数据成员用**multable**关键字修饰
- 类内初始值，必须使用`=`的初始化方式或者**花括号**括起来的直接初始化形式

### 返回*this的成员函数

- 通过返回非常量的this，使得函数调嵌入到一组序列中：`myScreem.move(4, 0).set('#')`
- 当函数`display`是const成员函数时候，j即使对象是非常量，返回的this也是**指向常量**的常量指针，无法使用`myScreem.display(4, 0).set('#')`

- 使cosnt成员函数返回常量对象的引用，重启其函数为非const成员函数并返回非常对象的引用，实现区分。

### 类类型

- 类名字不一样，即使类成员一样，也是两个不同类型
- 类名作为类型的名字使用；或关键字**class**或**struct**后跟类名作为类型名
- 前向声明：`class Screen;`或`struct Data;`
- 不完全类型：前向声明后，到类型定义为止；有限的使用情景
  - 定义指向这种类型的指针或引用
  - 声明以不完全类型作为参数或返回类型的函数；

- 类成员不能是自己，因为只有完全完成后类才算被定义；但类成员允许指向自身类型的指针或引用，因为类名出现后就认为已经声明

### 友元再探

- 友元函数可以定义再类内，这样函数是隐式内联的
- `friend class Window_mgr;`指定`window_mgr`为该类的友元类
- 友元类的成员函数可以访问包括非公有成员内所有的成员。
- **友元关系不存在传递性**
- 类的成员函数作为友元：`friend void Window_mgr::clear(Screen Index);`
  - 声明Screem类
  - 定义Window_mgr类，其中声明clear函数
  - 定义Screen类，并对clear进行友元声明
  - 定义clear，此时才能使用Screen的成员
- 一组重载函数声明为友元，需要每个函数分别声明



## 类的作用域

- 类作用域之外的访问：
  - 成员访问运算符可以访问：对象、引用、指针的普通数据成员和函数成员
  - 作用域运算符可以访问：类类型成员
- 一个类就是一个作用域，因此类外部定义成员函数必须同时提供类名和函数名
- 因为返回类型在类名出现之前，返回类型中使用的名字都位于类的作用域之外

### 名字查找与类的作用域

- 类定义的两步处理：
  - 编译成员的声明
  - 类全部可见后编译函数体
- 在类中，如果成员使用了外层作用域中的某个名字，而且该名字代表一种类型，则**类不能在之后重新定义该名字**



## 构造函数再探

### 构造函数初始化列表

- 一般情况下，构造函数可以对成员变量进行**初始化**或者**赋值**，两者无差异
- 必须**初始化的情况**：
  - 成员是`const`或者引用，则**必须初始化**
  - 成员是类类型，且**没有默认构造函数**
- 构造函数体一开始执行，构造函数初始化完成
- 成员初始化顺序：与类定义中成员变量的循序一致；避免使用对象成员初始化对象成员
- 如果一个构造函数为所有餐宿提供了默认实参，则它实际上也定义了默认构造函数

### 委托构造函数

- 定义：使用类内其他构造函数执行它自己的初始化过程，或把一些或全部职责委托给其他构造函数
- 成员初始值列表**只有一个唯一入口**，就是**类名本身**

### 默认构造函数的作用

- 实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数
- 使用默认构造函数：`class_name object_name;`

### 隐式的类类型转换

- **转换构造函数**：只接受一个实参的构造函数。其实际上定义了将构造函数的参数类型转换为此类类型的隐形转换机制。
- 只允许**一步**类类型转换

```C++
//类中声明的函数
Sales_data& Sales_data::combine(const Sales_data &input);
//显示转换C风格字符串为String，隐式转换为Sales_data
item.combine(string("9-999-99999-9"));
//隐式转换C风格字符串为String，显示转换为Sales_data
item.combine(Sales_data("9-999-99999-9"));
//需要两部转换，所以是错误的；C风格字符串->String->Sales_data
item.combine("9-999-99999-9");
```

- 抑制构造函数定义的隐式转换：**声明单个参数**的构造函数时，在函数最前面使用**explicit**关键字。
- explicit关键字声明的构造函数，只能使用直接初始化，不能用于拷贝形式的初始化（=）
- 可将explicit的构造函数用于**显式地强制**进行转换：（1）类型直接构造；（2）static_cast<类型>强制转换

### 聚合类

- 聚合类的条件
  - 都是public成员
  - 没有构造函数
  - 没有类内初始值
  - 没有基类和virtual函数
- 初始化方式：或括号括起来的成员初始值列表，初始值的顺序必须与声明的顺序一致。

### 字面值常量类

- 字面值常量类：
  - 数据成员是字面值类型的**聚合类**
  - 满足以下所有条件的**非聚合类**
    - 数据成员都是字面值
    - 至少有一个constexpr构造函数
    - **内置类型**数据成员若有初始值，必须是**常量表达式**；或数据成员是**类类型**，则必须使用成员自己的**constexpr构造函数**
    - 类使用析构函数的默认定义
- constexpr构造函数：
  - 通过前置关键字`constexpr`至少提供一个`constexpr`构造函数
  - `cosntexpr`构造函数必须初始化所有数据成员
- constexpr函数必须有返回语句



## 类的静态成员

- 类的静态成员：类中与类本身直接相关，而不是与类的各个对象保持相关
- 声明静态变量
  - 声明静态变量：成员声明前加`static`关键字
  - 静态变量可以是`public`或者`private`
  - 静态变量处于任何对象之外，不用任何对象绑定，不包含`this`指针
  - 静态变量不能声明为`const`，也不能在`static`函数体内使用`this`指针
- 使用静态变量
  - 使用**作用域运算符**直接访问静态成员
  - 成员函数可以直接使用静态变量
- 定义静态变量
  - 既可以类内，也可以类外定义静态成员函数
  - 类外定义不能重复`static`关键字
  - 静态数据成员只能被在类外定义和初始化一次
  - 生命周期：整个程序期间
  - 将静态数据成员的定义与其他非内联函数的定义放在同一个文件中
- 静态成员的类内初始化
  - 静态成员是字面值常量类型的constexpr，初始值必须是常量表达式
  - 类内初始化了，类外成员定义就不能再指定一个初始值了
  - 即使类内初始化了，也要类外定义
- 静态成员的使用场景
  - 声明时：静态成员可以声明为自己的类类型；非静态成员只能是自己类类型的指针或引用
  - 可以使用静态成员作为默认实参（成员必须是const类型）
  - 非静态变量不能作为默认实参，应为其是对象一部分，不饿能真正提供一个对象以便从中获取成员的值

