# 类

- 类的基本思想：通过定义一个抽象数据类型，实现数据抽象和封装
- 数据抽象是一种依赖于接口和实现分离的编程技术



## 定义抽象数据类型

### 定义类类型

- 定义在类内部的函数时**隐式的inline函数**
- 定义成员函数
  - 成员函数可以定义在类内，也可以定义在类外
  - 类内的函数定义与一般函数一样
  - 编译器处理类的步骤：（1）编译成员声明；（2）编译成员函数体
  - 因此成员函数体随意使用类中其他成员，**无需在意这些成员出现的顺序**
  - 类内声明函数，类外定义函数时，类外定义的函数名字前需要加上类作用域：`类目::函数名`

### 引入**this**指针

- 调用类的成员函数，就是替某个对象调用；
- 如果成员函数使用类的成员，则成员函数**隐式地**指向调用该函数的对象的成员
- 成员函数通过**this**的额外的隐式参数来访问调用它的那个对象
- 在成员函数内部，**不需要成员访问运算符**，任何对类成员的访问都被看作this的隐式引用
- **this时一个常量指针**

### 引入`cosnt`成员函数

- 紧随参数列表止之后的`const`关键字，会修改隐式`this`指针的类型
- 默认情况：`this`指向类类型**非常量**版本的常量指针,即`Sales_data *const`，不能绑定到常量对象
- 紧随参数列表之后的`cosnt`，将`this`指针指向常量对象的常量指针，即`const Sales_date *const`
- 使用`cosnt`的成员函数称为**常量成员函数**，`this`是常量指针，在函数内不能改变对象的内容
- **常量对象以及常量对象的引用或指针只能调用常量成员函数**

- 函数被声明为常量成员函数，则定义也需要子啊参数列表后名且指出`const`属性

### 返回this对象的函数

- 返回类型是类类型的引用，`return`语句返回`*this`

### 定义类相关的非成员函数

- 有些函数是类接口的一部分，但不属于类本身
- 一般跟**类声明**在同一个头文件里
- **IO类属于不可被拷贝类型**，只能使用引用
- 输出任务的函数尽量减少对格式的控制
- 拷贝类的对象其实拷贝的是类对象的数据成员。

### 构造函数

- 构造函数：类通过一个或几个特殊的成员函数来控制其对象的初始化过程
- 构造函数名与类名一样；不同构造函数要在参数数量或参数类型上有所区别；构造函数不能被声明成`const`
- 默认构造函数：对象初始化没有初始值，无需任何实参
- 合成的默认构造函数：编译器创建的构造函数；有类内初始值，用它初始化对象；否则默认初始化。
- **必须定义自己的默认构造函数**的原因：
  - 编译器只会在发现**没有任何构造函数**情况下才合成默认构造函数；所以自己必须定义默认构造函数
  - **合成的默认构造函数**可能指向错误操作
  - 编译器不能为某些类合成默认构造函数
- 编译器生成构造函数
  - 在参数列表后面写上`= default`
  - 既可以和声明一起在类内，也可以作为定义出现在类外
  - 类内部内联；外部不是内联
- 构造函数初始值列表

### 拷贝、赋值和析构

- 对象拷贝的情况
  - 初始化变量
  - 以值的凡是传递
  - 返回一个对象
  - 赋值操作符
- 这些操作可以编译器生产；生产的版本将对对象的每个成员指向拷贝、赋值和销毁
- 类的合成版本失效的情况：当类需要分配类对象之外的资源时
- 使用`vercor`和`string`的类能避免分配和释放内存带来的复杂性；即类包含`vector`或`string`成员，则其拷贝、赋值和销毁的合成版本能够正常功能。



## 访问控制与封装 