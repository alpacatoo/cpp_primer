# 第2章 变量和基础类型

## 算术类型
　　算数类型是一个基本内置类型，分为整型（包括布尔和字符型）和浮点型。其包括：

| 类型 | 含义 | 最小尺寸 | 分类 |
|---|---| ---| --- |
| `bool` | 布尔类型 | 未定义 | 整型（布尔） |
| `char` | 字符 | 8 Bits | 整型（字符型） |
| `wchar_t` | 宽字符 | 16 Bits | 整型（字符型） |
| `char16_t` | Unicode字符 | 16 Bits | 整型（字符型） |
| `char32_t` | Unicode字符 | 32 Bits | 整型（字符型） |
| `short` | 短整型 | 16 Bits | 整型（整数类型） |
| `int` | 整型 | 16 Bits | 整型（整数类型） |
| `long` | 长整型 | 32 Bits | 整型（整数类型） |
| `long long` | 长整型 | 64 Bits | 整型（整数类型） |
| `float` | 单精度浮点型 | 6位有效数字 | 浮点型 |
| `double` | 双精度浮点型 | 10位有效数字 | 浮点型 |
| `long double` | 扩展精度浮点型 | 10位有效数字 |

### 表示空间
- **布尔类型**：取值为`true`或`false`
- `char`：占用一个机器字节，即1 Byte。
- **表示空间比较**：`short`$\leq$`int`$\leq$`long`$\leq$`long long`；一般情况下，`int`大小为一个字，即在32位机上位4 Bytes，在64位机上为8 Bytes。
- `float`实际使用1个字（32 Bits）表示，有`7个有效位`。
- `double`实际使用2个字（64 Bits）表示，有`16个有效位`。
- `long double`使用3或4个字表示，精度根据硬件不同实现

### 带符号与无符号
- 无符号表示大于0的数，带符号表示正数、负数和0。
- `short`、`int`、`long`、`long long`是带符号数，其无符号形式在前端添加`unsigned`，例如`unsigned int`。
- 字符型分为无前缀、`signed`前缀、`unsigned`前缀三种，其中`signed`前缀表示有符号；`unsigned`前缀表示无符号；无前缀由编译器决定有无符号，一般编译器添加`signed`前缀。



## 类型转换

- 非布尔类型到布尔类型：`0`表示`false`；否则为`true`
- 布尔类型到非布尔类型：`false`转为`0`；`true`转为`1`
- 浮点类型到整数类型：保留小数之前的数值
- 整数类型到浮点类型：效数部分补为`0`
- 有符号整数转换为无符号整数：数值为负数时，将负数加上类型的模



## 字面值常量

- 整型字面值常量：默认为十进制数，`0`开头表示八进制数，`0x`或`0X`开头表示十六进制；十进制字面值是带符号数
- 浮点型字面值：表现为小数或以科学技技术法表示的指数，指数部分用`E`或`e`标识；例如`3.12e3`；浮点型字面值是一个`dobule`类型。
- char型字面值：使用**单引号**包围的一个字符
- 字符串字面值：使用**双引号**包围的一个或多个字符；编译器会在么个字符串结尾添加一个空字符（`'\0'`）
- 转移字符：这是一类不可打印字符，包括控制字符（例如`\n`）和C++语言的特殊字符(单双引号等)。有三中表示方式：
  - （1）`\`后紧跟字符；
  - （2）`\`后紧跟1个、两个、三个八进制数；
  - （3）`\x`后紧跟十六进制数
- 布尔字面值：`true`、`false`
- 指针字面值：`nullptr`
- 指定字面值类型，改变字面值默认的类型：
  - 字符和字符串字面值（前缀）：
    - u：`char16_t`类型，例如`u'a'`
    - U：`char32_t`类型，例如`u'a'`
    - L：`wchar_t`类型，例如`L'a'`
    - u8：`char`类型，表示UTF8
  - 整型字面值（后缀）：
    - u or U：`unsinged`，例如`42ULL`表示类型为unsigned long long
    - l or L: `long`
    - ll or LL：`long long`
  - 浮点型字面值（后缀）：
    - f or F：`float`，例如`1E-3F`表示类型为float
    - l or L：`long double`



## 变量

　　变量提供一个具名的、可提供操作的存储空间，每个变量都有其数据类型。对于C++来说，变量（variable）和对象（object）一般可以互换使用；对象（object）是具有牟总数据类型的内存空间。

### 定义变量

- 变量定义的基本形式如下所示，由**类型说明符**起头，紧随一个或多个**变量名**，变量名之间用逗号分隔，最后以分号结束。更通用的定义是**基本数据类型（base type）**起头，紧跟一个或多个**声明符（declarator）**。

```C++
type_specifier variable_name_1, variable_name_2, ..., variable_name_n;
```

- 定义变量时可以给变量赋**初值**，这个过程被称为**初始化**（initialized）变量。先定义的变量在初始化后可以用来初始化其后边的变量。例如下方的程序表明最后的价格由先定义的原价和折扣计算获得

```C++
double origin_price = 99.99, discount = 0.78, final_price = origin_price * discount;
```

- C++具有四种初始化形式，用花括号来初始化的形式被成为**列表初始化**。当使用列表初始化且存在精度丢失风险时，编译器将报错。

```C++
int price = 10;
int price = {0};
int price{0};
int price(0);
```

- 没有指定初值的变量被**默认初始化（default initialized）**，变量被赋予默认值。
  - 定义在函数体之外的变量被初始化为`0`。
  - 定义在函数体之内的内置变量（整型、浮点型）将不被初始化。

### 变量声明与定义的关系

- C++语言支持分离式编译（separate compilation）。为了实现该特性，C++将声明和定义区分开。
- **声明（declaration）**将名字被程序所知；**定义（defination）**负责创建与名字关联的实体，申请空间并初始化。
- 变量只可以一次定义，但可以多次声明。变量声明时由`extern`标记且不能被显示的初始化。

```C++
extern int price;		//声明变量
extern int price = 3;	//在函数体外定义变量且赋初值为3；若在函数体内则会编译错误
```

### 标识符（identifier）

　　标识符由字母、数字、下划线组成，必须以字母或下划线开头，对大小写敏感。标识符不能与C++的关键字同名。

### 名字作用域

 　　**作用域（scope）**以花括号分割，同一个名字在不同作用域中指向不同的实体。

　　函数名在函数体之外，具有**全局作用域（global scope）**；声明后可以在整个程序范围内使用。在花括号内定义的对象，拥有**块作用域（block scope）**，在语句块结束时失效。

　　作用域可以彼此包含，被包含的作用域称为**内层作用域（inner scope）**，包含其他作用域的作用域称为**外层作用域（outer scope）**。C++允许内存作用域重新定义外层作用域已有的名字，此时内存作用域名字覆盖外层作用域的名字，直到内层作用域结束。



## 复合类型

### 引用（reference）

　　此时的引用指的是**左值引用（left reference）**，是为对象起另一个名字。定义变量时，声明符就是变量名；定义引用时，声明符写成`&variable`的形式，其中`variable`是变量名。

　　一般在初始化变量时，初始值被拷贝到变量中。然而定义引用时，程序把引用和变量**绑定（bind）**。由于初始化完成后，引用一直更变量绑定，因此引用**必须要初始化**。

　　引用只能绑定在对象上。因为引用不是对象，因此不能定义引用的引用。

### 指针（pointer）

　　指针是**指向（point to）**另一种类型的复合类型，本身就是一个对象，无需在定义时赋初值。定义指针时，将声明符写成`*variable`的形式，其中`variable`是变量名。一条语句定义多个指针，每个变量前都必须要有符号`*`。例如：

```C++
int *ip1, *ip2;
```

　　程序可以通过**取地址符（运算符&）**获取对象的地址；由于引用不是对象，所有不能定义指向引用的指针。当定义指针时，指针类型和对象类型需要严格的匹配。当指针指向一个对象，允许使用**解引用符（操作符*）**访问对象。

```C++
double dval;		
double *pd = &dval;	//正确，取地址定义指针
int *pi = &dval;	//错误，类型不匹配
*pd = 3.14;			//符号*得到pd所指向的对象dval，并复制
cout << *p;			//输出pd指向对象的数值，即3.14
```

　　指针的值应该属于4种状态之一：（1）指向一个对象；（2）指向紧邻对象所占空间的下一个位置；（3）空指针，不指向任何对象；（4）无效指针，除上述情况之外。访问无效指针的后果无法预计。

　　空指针有三种：（1）NULL；（2）字面常量0；（3）nullptr。NULL是一个预处理变量，在头文件`cstdlib`中定义；不能直接将数值为0的变量赋值给指针，只能赋值字面常量0；建议使用nullptr表示空指针。

　　指针和引用都是对其他对象的**间接访问**。赋值永远改变的是等号左侧的对象。任何非零的指针的条件值都是`true`。

　　**void * **指针是一个特殊指针，可以存放任意对象的地址。由于不知道指针指向什么类型的对象，所以不能直接操作其指向对象；它可以用于指针的比较、函数的输入输出、赋值给另一个void *指针。

### 复合类型的声明

　　**类型修饰符（*或&）**与变量名组成一个声明符；基本数据类型后紧跟一个或多个声明符即可定义多个复合类型变量。

　　类型修饰符在一个声明符中的个数不受限制。以指针为例，`*`的个数可以区分指针级别；`**`表示指向指针的指针，`***`表示指向指针的指针的指针。由于引用不是对象，因此不能定义指向引用的指针。但指针是对象，可以定义指向指针的引用。理解变量是什么复合类型，通过**从右往左**阅读变量的定义；离变量名最近的类型修饰符对变量的类型具有最直接的作用。

```C++
int ival = 1023;	//定义变量
int *pi = &ival;	//pi指向int型数
int **ppi = &pi;	//ppi指向一个int指针
int *&r = pi;		//r是一个对指针pi的引用；距离r最近的是&，表明r是一个引用，剩下的符号*表示引用的一个指针
```



## const限定符

### 初始化和const

　　**关键字const**对变量的类型加以限制，表明变量数值不能改变。因此被const限定的对象**必须初始化**，只能执行不改变内容的操作。

　　编译器在编译过程中将用到const对象的地方替换成对应的数值。为避免同一个变量的多次定义，const对象被设定为只在文件内有效，不同文件的多个同名const对象是各自独立的对象；当需要在多个文件中共享同一个const对象，则子啊一个文件中定义，多个文件中声明；不管定义还是声明，都添加`extern`关键字；声明的`extern关键字`表明bufSize并非cpp'文件独有的。

```C++
//file.cpp中定义const对象，即常量
extern const int bufSize = 512;
//file.h中声明该常量，在需要使用该常量的cpp文件中包含该头文件
extern cosnt int bufSize;
```

### const的引用

　　**对常量的引用（reference to const）**不能用于修改它所绑定的对象。C++允许对常量的引用绑定**非常量的对象**、**字面值**、**一般表达式**。对常量的引用绑定非常量对象时，实际绑定的是一个**临时量（temporary）**对象。

```C++
const int ci = 1024;
const int &r1 = ci;		//对常量的引用绑定常量对象
const int &r2 = 42;		//对常量的引用绑定字面值
const int &r3 = r1 * 2;	//对常量的引用绑定一般表达式
int &r4 = ci;			//错误，非常量引用不能绑定常量对象
int i = 100;
const &r5 = i;			//常量引用可以绑定非常量对象，
//常量引用绑定非常量对象的实质是r5绑定了临时常量temp
const int temp = i;
const int &r5 = temp;
```

### 指针与const

　　**指向常量的指针（pointer to const）**不能改变所指向的对象的值。要想存放常量对象的地址，只能使用指向常量的指针。C++允许指向常量的指针指向一个非常量对象，但不能通过该指针改变非常量对象的值。

　　**常量指针（const pointer）**必须初始化，且初始化后其值（对象的地址）不能改变。把符号`*`放在const限定符之前用以说明指针是一个常量。可以通过**从右往左阅读**弄清楚定义的含义。可以用口诀**左数右指**，即const限定符在符号`*`左边，指向的对象为cosnt；const限定符在符号`*`右边，则指针不变。

```C++
int errNum = 0;
int *const curErr = &errNum;	//cosnt表明变量curErr是常量，符号*表示是指针，即常量指针
const double pi = 3.1415;
const double *const ppi = &pi	//离ppi近的cosnt表示ppi是常量，符号*表示是指针，最左边表明指针指向常量，即指向常量的常量指针
```

### 顶层const

　　**顶层cosnt（top-level const）**表明**指针本身**是常量；**底层cosnt（low-level const）**表示指针所指的对象是常量。顶层const不影响对象的拷贝操作；拷入和拷出的对象必须具有享同的底层const，或数据类型可以相互转换。非常量可以转换成常量。

```C++
const int ci = 42;
const int *p1 = &ci;		//p1是底层const
const int *const p2 = &ci;	//p2即是顶层cosnt，也是底层const
p1 = p2;					//p2的顶层cosnt被忽略，p2具有底层cosnt，与p1一致。
int *p3 = p2;				//错误，p2有底层cosnt，但p3没有底层const
```

### constexpr和常量表达式

　　**常量表达式（const expression)**是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象或表达式是不是常量表达式由它的**初始值和数据类型**共同决定。

　　C++允许将变量声明为**constexpr类型**以便由编译器来验证变量是否为一个常量表达式。声明为constexpr的变量一定是常量，且用常量表达式初始化，例如：

```c++
constexpr int price = 20;
constexpr int discount_price = price * 0.6;
```

　　constexpr定义指针时，只对指针有效，对指针所指对象无效，它把所定义对象置为了顶层const。

```C++
const int *p = nullptr;			//p是一个指向整型常量的指针
constexpr int * q = nullptr;	//p是一个指向整型的常量指针
```



## 处理类型

### 类型别名

　　**类型别名（type alias）**是一个名字，是某种类型的同义词。有两种方法定义类型别名：（1）传统**关键字typedef**；（2）使用**别名声明（alias declaration）**。当使用传统typedef定义指针、常量的时候，注意定义的差别。

```C++
typedef char base;		//base类型是char类型的别名
typedef base go, *p;	//go类型是char类型的别名，p类型是char*的别名
using base = char;  	//base类型是char类型的别名
base charactor;			//等价于char charactor
//类型别名不是直接类型名替换
typedef char *pstring;	//pstring类型是char*类型的别名
const pstring cstr = 0;	//基础类型是指向char的指针，所以cstr是指向char类型的常量指针。const表明基础类型是常量
const char *cs = 0;		//基础类型是char，cosnt修饰基础类型是常量，cs是指针，所以cs是指向char常量的指针
const pstring *ps;		//基础类型是指向char的指针，const修饰指针为常量,由于有符号*，故ps是指针，ps是一个指针，指向一个char的常量指针
```

### auto类型说明符

　　**auto类型说明符号**用来让编译器替我们分析表达式所属数据类型；因此必须初始化初始值。auto声明变量时候的相关规则：（1）auto类型说明符可以一条语句声明多个变量，但基础数据类型必须一致。（2）引用被作为初始值时，真正参与初始化的是**引用对象的值**。（3）auto一般会**忽略顶层const**，如果希望推断出顶层cosnt，需要显示使用const指出。（4）设置**auto的引用**时，顶层常量属性仍然保留。（5）声明多个变量时，符号`*`和符号`&`从属于声明符。

```C++
//规则1：
auto i = 0, *p = &i; &r = i;	//正确，i是是整数，p是整型指针，r引用了整型变量i
auto sz = 0, pi= 3.14;			//错误，sz和pi类型不一致
//规则2:
auto a = r;		//a是整数。r是i的别名，i是一个整数
//规则3：
const int ci = i, &cr = ci;
auto b = ci;	//ci是cosnt int类型，顶层const被忽略，故b是int类型变量
auto c = cr;	//cr是ci的别名，实际参与初始化的是ci，故c是int类型变量
auto d = &i;	//变量地址是int类型指针，故d是int型指针
auto e = &ci;	//变量地址是int类型指针,
```

### decltype类型说明符

- 使用场景：希望使用表达式的类型推断定义的变量类型，但不希望使用表达式的值初始化变量
- decltype处理顶层const和引用的方式与auto不同
  - decltype使用的表达式**是一个变量**，则decltype返回该变量的类型，包括**顶层const和引用在内**
  - decltype使用的表达式**不是一个变量**，则decltype返回表达式结果对应的类型
  - delcltype使用解引用操作，则decltype将得到引用类型

```C++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;		//x的类型是const int
decltype(cj) y = x;		//y的类型是const int&
int i = 40, *p = &i, &r = i;
decltype(r+0) b;		//加法的结果是int，故b类型是int
decltype(*p) c;			//解引用操作得到引用类型，c是int&
```

- decltype的结果类型与表达式形式密切相关。**decltype( (variable) )**的结果永远是variable类型的**引用**，**declatype(variable)**的结果是variable类型 ，当variable是引用时结果才是引用。



## 自定义数据结构

### 定义struct

- 以关键字struct开始，紧跟类名和类体。类体由花括号包围形成一个新的作用域。右花括号后必须有分号。

```C++
struct struct_name {/*struct body*/} variableA;
//等价于
struct struct_name {/*struct body*/};
struct_name variableA;
```

- 数据成员定义了类的对象的具体内容。
- 类内初始值（in-class initializer）：初始值可以放花括号，或者放等号右边，**不能使用圆括号**

### 编写头文件

- 头文件通常包含只能定义一次的实体，如类、const、constexptr变量
- 预处理器看到`#includde`标记时就会用指定的头文件内容代替`include`
- 头文件包含符（header guard）依赖预处理器变量；预处理变量有两种状态；已定义和未定义
  - `#define`指令把一个名字设定为预处理变量
  - `#ifde`当且仅当变量已定义时为真
  - `#ifndef`当且仅当变量为定义时为真
  - `#endif`为检查为真后，指向后续操作到该指令为止

```C++
#ifndef A_H
#define A_H
/*其他操作*/
#endif
```







　　

