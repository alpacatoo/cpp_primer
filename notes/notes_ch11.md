# 第11章 关联容器

- 两个主要关联容器：map，set
- 容器默认关键字不可重复，重复的关联容器名字中加`multi`
- 不保持容器的顺序使用`unorder`开头
- 有序的map（不管是否重复关键字）在**map**头文件；有序的sset（不管是否重复关键字）在**set**头文件
- 无序容器定义在**unordered_map**和**unordered_set**头文件中

## 11.1 使用关联容器

- map容器
  - map类型通常被称为关联数组；定义时指定关键字和值的类型；例如，`map<string, size_t> word_count;`
  - 访问元素：`word_count[key_name]`；通过关键字直接访问元素，**赋值时，若关键字不存在，则创建该键值对**
  - 从map中提取元素时，会得到一个`pair`类型的对象，用`first`成员保存关键字，用`second`成员保存对应值
- set容器
  - 定义：`set<key_type>`，例如，`set<strng>`
  - 可以进行列表初始化，例如，`set<string> exclude = {"The", "But"}`
  - 使用成员函数find查找一个单词是否存在



## 11.2 关联容器概述

- 不支持书匈奴容器的位置相关的操作
- 关联容器的迭代器是双向的

### 定义关联容器

- 定义map时，必须芝麻关键字类型又指明值类型
- 定义set时，只需要指明关键字类型
- 关联容器具有默认构造函数，会创建一个指定类型的空容器；或另一个同类型容器的拷贝；或一直值范围初始化
- 每个键值对用花括号包围：`{key, value}`
- map和set的关键字必须唯一；multimap和multiset的关键字表可以不唯一

### 关键字类型要求

- 有序关联容器关键字类型必须定义元素比较的方法；默认使用`<`进行比较
- 有序关联容器的关键字类型
  - 必须定义一个严格弱序
  - 比较函数需要满足的基本性质
    - 不能同时小于等于对方
    - 比较具有传导性
    - 均不小于等于对方，则等价
- 定义multiset时候，若关键字没有<操作符，则必须提供比较操作类型，这是一种寒素指针类型：`multiset<Sales_data, decltype(compareIsbn)*>

### pair类型

- 定义在头文件`utility`中
- `pair`是一个用来上特定类型的模板
- `pair`的数据成员是public的，两个成员分别命名为`first`和`second`
- `map`的元素是`pair`
- 构造函数初始化
  - 默认构造函数值初始化：`pair<stirng, string> anon;`
  - 提供值进行值初始化：`pair<string, string> author{"James", "Joyce"};`
- **花括号包围的初始化器返回pair类型**：`return {num_1, num_2};`
- 创建pair对象的**函数**：`make_pair`，例如，`make_pair(num_1, num_2);`
- 关系运算符：先比较`first`成员，在`first`成员相等情况下，再比较`second`成员
- 相等运算符：`first`成员和`second`成员都相等的情况下，才算相等



## 11.3 关联容器操作

- 容器关键字和值的类型

  - `key_type`：容器类型的**关键字**类型

  - `mapped_type`：每个关键字关联的类型；只适用于`map`

  - `value_type`：

    - `set`情况下，`value_type`等于`key_type`
    - `map`情况下，`value_type`等于`pair<const key_type, mapped_typed>`
    - 由于不能改变一个元素的关键字，因此`pair`的关键字部分是`const`
- 使用作用域运算符来提取一个类型的成员，例如，`map<string, int>::key_type>`

### 11.3.1 关联容器迭代器

- 解引用一个关联容器迭代器时，我们会得到一个类型为容器的`value_type`的值的引用
- `set`的迭代器是`const`的；虽然其定义了`iterator`和`const_iterator`类型，但都只运行制度访问`set`的元素
- 遍历关联容器
  - 获得首个迭代器，判断是否为尾后迭代器进行遍历
  - 遍历的迭代器按照**关键字升序遍历元素**
- 关联容器只可用于只读取元素的算法；几乎不用泛型算法
- 关联容器使用算法，将它当作一个源序列，要么当作一个目的位置

### 11.3.2 添加元素

- 关联容器的`insert`成员函数，插入`key`重复的数值对容器没有影响

- `insert`有两个版本，分别接受一对迭代器，或是一个初始化器列表

- `insert`操作

  - `c.insert(v)`和`c.emplacee(args)`

    - 入参：`v`是`value_type`类型的对象，`args`用来构造一个元素的

    - 返回值：

      - `map`和`set`返回一个`pair`对象，包含一个指向关键字元素的迭代器，以及指示是否成功的bool值
      - **multimap**和**multiset**，总会插入给定元素，返回指元素的迭代器

    - 例子

      ```C++
      //插入的4种方法
      word_count.insert({word, 1});
      word_count.insert(make_pair(word, 1));
      word_count.insert(pair<string, size_t>(word, 1));
      word_count.insert(map<string, size_t>::value_type(word, 1));
      ```

  - `c.insert(b, e)`和`c.insert(il)`

    - 入参：
      - `b`和`e`是迭代器，表示一个`c::value_type`类型值的范围
      - `il`表示该类型值的花括号列表
    - 返回值：`void`

  - `c.insert(p, v)`和`c.emplace(p, v)`：再指定`p`位置开始搜索新元素存储的位置；

- `insert`返回值总结：没有重复关键字的容器，返回pair，first表示迭代器，second表示是否成功插入，有重复，则返回false

### 11.3.3 删除元素

- 关联容器提供三个版本的`erase`。
- 两个版本与顺序容器一样
  - 传递一个迭代器，删除该迭代器。
  - 传递一对迭代器，删除迭代器对范围内的元素。
  - 两个版本的`erase`返回值均为`void`
- 关联容器特有的版本
  - 传递一个**key_type**参数，删除所有匹配给定关键字的元素，返回实际删除的元素个数
  - 对于不重复关键字的容器，`erase`的返回值总是`0`或`1`
  - 对于允许重复关键字的容器，删除元素的数量可能大于1

### 11.3.4 map的下标操作

- **map**和**unordered_map**容器提供了**下标运算符**和一个对应的**at函数**
- **set**类型不支持下标，元素本来就是关键字，通过关键字找关键字的操作无意义
- **multimap**和**unordered_multimap**不能进行下标操作，因为一个关键字与多个值相关联
- map的下标运算符操作
  - 如果关键字不在map中，则创建一个元素并插入到map中，关联值将进行**值初始化**
  - 由于可能插入新元素，只可以对非const的map使用下标操作
- map的at成员函数：访问关键字k的元素，带参数检查；若k不在map中，则抛出一个out_of_range异常
- map下标操作与通常情况比较
  - 不同点：
    - 通常解引用一个迭代器返回的类型与下标运算符返回的类型是一样的。
    - map进行下标操作，返回一个**mapped_type**对象；解引用一个map迭代器，会得到一个**value_type**对象
  - 相同点：map的下标运算符返回一个左值，既可以读也可以写元素

### 11.3.5 访问元素

- 成员函数find：`c.find(k)`，输入关键字`k`，返回关键字等于`k`元素的迭代器；不存在关键字为`k`的元素则返回尾后迭代器
- 成员函数count：`c.count(k)`，输入关键字`k`，返回关键字等于`k`的元素个数
- 对于不允许重复关键字的容器，find成员函数与count成员函数无区别；
- 可以重复关键字的容器，不需要计数查找元素的个数，建议使用find成员函数；
- 对于`map`和`unordered_map`类型，由于使用不存在的关键字作为下标，会插入一个新元素，故查找是否存在元素使用`find`成员函数
- `multimap`和`multiset`中查找元素
  - 方法一：利用相邻存储
    - 使用成员函数`count`获得指定关键字的元素个数
    - 使用成员函数`find`找到第一个指定关键字的元素，并返回指向该元素的迭代器
    - 由于**重复关键字会相邻存储**，因此可以通过元素个数移动迭代器获得其他相同关键字的元素
  - 方法二：利用`lower_bound`和`upper_bound`这两个成员函数
    - 成员函数`lower_bound`返回迭代器将指向第一个具有给定关键字的元素
    - 成员函数`upper_bound`返回迭代器将指向最后一个匹配给定关键字的元素之后的位置
    - 当关键字不存在，两个成员函数返回的迭代器相等，且**指向一个不影响排序的关键字插入位置**
    - 查询的关键字不存在时，`lower_bound`返回的迭代器将指向第一个关键字大于查询关键字的元素；可能是尾后迭代器
  - 方法三：成员函数`equal_range`，接受一个关键字，返回一个迭代器`pair`；本质与方法二一样，只是不需要局部遍历保存迭代器



## 11.4 无序容器

- 不使用比较运算符组织元素，而是使用一个哈希函数和关键字类型的`==`运算符
- 使用与有序关联相同，指示输出的关键字不是按字节序的
- 管理桶
  - 存储上组织是一组桶，每个桶保存零个或者多个元素。
  - 容器计算元素哈希值，特定哈希值的所有元素都保存在相同的桶中
  - 无需容器的性能依赖于哈希函数的制类和桶的数量和大小









