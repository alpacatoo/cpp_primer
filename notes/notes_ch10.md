# 第10章 泛型算法

- **泛型算法**：用于不同类型的元素和多种容器类型的算法。generic，通用的，泛型的



## 10.1 概述

- 大多数泛型算法在头文件`algorithm`中；数值泛型算法在头文件`numeric`中定义
- 泛型算法操作迭代器
- 标准库中使用`begin`和`end`函数获得数组的迭代器
- 算法依赖于元素类型的`==`和`<`操作



## 10.2 初识泛型算法

- 除少数例外，标准算法都是对**范围内的元素进行操作**

### 只读算法

- `find`，`count`，`accumulate`
- `accumulate`前两个参数时迭代器，界定范围；第三个参数是**累加初始值**，参数类型必须与元素类型匹配，或者能转换为第三个参数的类型
- 对`accumulate`算法，第三个参数不能是`const char*`类型，即字面值类型，因为不能保存结果。头文件**numeric**中
- `equal`确定序列相等；第1、2个参数确定第一个序列范围，第3个参数是第二个序列首元素。假定第二个序列长度与第一个一样长

### 写容器算法

- 需要确保序列原大小至少不小于我们要求算法写入的元素数目
- `fill`的第1、2参数用迭代器表示范围，第3个参数为写入的值
- `fill_n`第1个参数表示开始元素，第2个参数是个数，第3个参数为写入的值
  - 重置所有元素：`fill_n(v.begin(), v.size(), 0)`
  - 不能在空容器上调用`fill_n`；例如向空迭代器写入10个元素：`fill_n(v.begin(), 10, 0)`
- `back_insert`定义在**iterator**头文件中；得到**插入迭代器**
  - 插入迭代器是添加元素的迭代器
  - 利用`fill_n`向空容器添加10个元素：`fill_n(back_itsert(v), 10, 0)`
  - 等价于每次赋值都向`v`上调用`push_back`
- 拷贝算法
  - `copy()`：参数1和参数2表示原目标的一对迭代器；参数3是目标的起始地址；返回目标的尾后元素
  - `replace`：参数1和参数2表示输入序列范围；参数3为查找数值；参数4是替代数值
  - `replace_copy`：参数1和参数2表示输入序列范围；参数3是**插入迭代器；参数4为查找数值；参数5是替代数值

### 重排元素的算法

- `sort`函数利用运算符`<`实现排序；
- `unique`获得不重复元素，返回不重复元素的尾后迭代器；但容器中元素个数不变，需要容`erase`删除
- 算法对迭代器操作，所以不能直接添加或删除元素。

