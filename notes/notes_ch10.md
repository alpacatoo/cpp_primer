# 第10章 泛型算法

- **泛型算法**：用于不同类型的元素和多种容器类型的算法。generic，通用的，泛型的



## 10.1 概述

- 大多数泛型算法在头文件`algorithm`中；数值泛型算法在头文件`numeric`中定义
- 泛型算法操作迭代器
- 标准库中使用`begin`和`end`函数获得数组的迭代器
- 算法依赖于元素类型的`==`和`<`操作



## 10.2 初识泛型算法

- 除少数例外，标准算法都是对**范围内的元素进行操作**

### 只读算法

- `find`，`count`，`accumulate`
- `accumulate`前两个参数时迭代器，界定范围；第三个参数是**累加初始值**，参数类型必须与元素类型匹配，或者能转换为第三个参数的类型
- 对`accumulate`算法，第三个参数不能是`const char*`类型，即字面值类型，因为不能保存结果。头文件**numeric**中
- `equal`确定序列相等；第1、2个参数确定第一个序列范围，第3个参数是第二个序列首元素。假定第二个序列长度与第一个一样长

### 写容器算法

- 需要确保序列原大小至少不小于我们要求算法写入的元素数目
- `fill`的第1、2参数用迭代器表示范围，第3个参数为写入的值
- `fill_n`第1个参数表示开始元素，第2个参数是个数，第3个参数为写入的值
  - 重置所有元素：`fill_n(v.begin(), v.size(), 0)`
  - 不能在空容器上调用`fill_n`；例如向空迭代器写入10个元素：`fill_n(v.begin(), 10, 0)`
- `back_insert`定义在**iterator**头文件中；得到**插入迭代器**
  - 插入迭代器是添加元素的迭代器
  - 利用`fill_n`向空容器添加10个元素：`fill_n(back_itsert(v), 10, 0)`
  - 等价于每次赋值都向`v`上调用`push_back`
- 拷贝算法
  - `copy()`：参数1和参数2表示原目标的一对迭代器；参数3是目标的起始地址；返回目标的尾后元素
  - `replace`：参数1和参数2表示输入序列范围；参数3为查找数值；参数4是替代数值
  - `replace_copy`：参数1和参数2表示输入序列范围；参数3是**插入迭代器；参数4为查找数值；参数5是替代数值

### 重排元素的算法

- `sort`函数利用运算符`<`实现排序；
- `unique`获得不重复元素，返回不重复元素的尾后迭代器；但容器中元素个数不变，需要容`erase`删除
- 算法对迭代器操作，所以不能直接添加或删除元素。



## 10.3 定制操作

- 默认情况，算法使用元素类型的`<`和`==`运算符完成比较
- 标准库允提供自己定义的操作来代替默认运算符

### 向算法传递函数

- 谓语是一个可调用的表达式，其返回结果是要给能用作条件的值
- **一元谓语**接受单一参数；**二元谓语**接受两个参数
- 一些算法的重载接受谓语；例如`sort`
- `stable_sort`算法是稳定排序，维持相等元素的原有顺序
- `partition`算法；当谓语为`true`时将元素排在容器的前半部分，否则将元素放后半部分；返回指向最后为为`true`之后的元素

### lambda表达式

- lamda表达式为了突破算法对**谓语的实参个数的限制**
- `find_if`算法查找特定大小的元素，第三个参数是**一元谓词**；返回第一个使谓词非0的元素，如果不存在则返回尾后迭代器。
- **一元谓词**只能传递一个实参
- 算法可以传递任何类别的**可调用对象**
- **可调用对象**是可以使用调用符号的对象或者表达
- 到目前学过的可调用对象：函数、函数指针、**lamda表达式**
- **lamda表达式**表示一个可调用的的代码单元；可以理解为一个未命名的内联函数。
- lamda表达式形式：
  - `[capture list] (paramter list) -> return type {function body}`
  - `capture list`是捕获列表，是lambda所在函数中定义的**局部变量**，**通常为空**
  - `paramter list`，`return type`，`function type`与任何普通函数一样，表示参数列表，返回值，函数体
  - **区别**：返回值必须使用**尾置返回**
  - 参数列表和返回值可以**忽略**，参数列表忽略时为空，返回值根据`return`语句推断出类型
  - 捕获列表和函数体**不能忽略**；捕获列表可以为空，只有**中括号**；
- lamda表达达式不能使用**默认参数**
- 捕获列表为空，表示函数里不使用局部变量；通过捕获列表传递更多的**谓语**
- `for_each`算法，接受一个可调用对象，并对输入序列中每个元素调用此对象

### lambda捕获和返回值

- 定义lambda时，编译器生产一个未命名的新的**类类型**
- 函数传递lambda时，同时定义一个**新的类类型**和**该类型的未命名对象**
- 从lambda生成的类都包含一个对应lambda所捕获的变量的数据成员；在lambda对象创建时被初始化
- **变量的捕获方式**：（1）值；（2）引用
- 值捕获的方式：`[names]`；names是逗号分隔的名字列表；要求变量是可拷贝的
- 引用捕获方式：值捕获的名字列表的名字前加`&`
- 隐式捕获：根据lambda函数体代码推断捕获哪些变量
  - `[=]`：表示隐式值捕获
  - `[&]`：表示隐式引用捕获
- 混合捕获：隐式捕获+显示捕获；隐式捕获的`=`或者`&`必须在中括号的最前
  - 例如：`[=, identifier_list]`；隐式捕获使用值捕获，显示捕获根据list的情况
  - 例如：`[&, identifier_list]`；隐式捕获使用引用捕获，显示捕获根据list的情况
- 可变lambda
  - 对于值被拷贝的变量，lambda不改变其值；通过在参数列表首加上关键字**mutable**使得值捕获变量可以改变数值
  - 引用捕获能否改变变量，取决于引用的是`const`还是非`cosnt`类型；
- `transform`算法接受三个参数，第1、2参数为迭代器，表示输入序列范围；第3参数为目的首地址；接受一个lambda谓语
- lambda体包含`return`语句之外的语句，编译器**推断返回类型是void**
- lambda返回类型通过尾置返回类型

### 参数绑定

- 一个操作需要很多语句才能完成时，通常使用函数更好

- lambda表达式的捕获列表为空，则可以用函数来替代它

- 当lambda表达公式的捕获列表不为空，则使用`bind`函数绑定参数

  - 一般形式：`auto newCallable = bind(callable, arg_list)`
  - `arg_list`中可能包含形如`_n`的名字，其中`n`是一个整数，是占位符
  - 例子，捕获列表被绑定，参数通过占位符绑定

  ```C++
  //lambda
  auto wc = find_if(words.begin(), words.end(),
                   [sz](const string &a));
  //替换为
  auto wc = find_if(words.begin(),words.end(),
                   bind(check_size, _1, sz))
  ```

- 占位符的声明空间：`using std::placeholders`

- 重排调用给你参数顺序

```C++
// f的第1，2，4参数分别被绑定到a, b, c的数值
auto g = bind(f, a, b, _2, c, _1);
// 调用绑定后的函数g
g(X, Y);
// 等价的调用f参数
f(a, b, Y, c, X);
```

- 绑定引用参数
  - 默认情况，`bind`的占位符的参数**被拷贝**到`bind`返回的可调对象中；
  - **ref()**函数，返回对象的引用；**cref()**函数，返回`const`引用的对象；
  - 上述函数定义在**functional**头文件中

