# 第10章 泛型算法

- **泛型算法**：用于不同类型的元素和多种容器类型的算法。generic，通用的，泛型的



## 10.1 概述

- 大多数泛型算法在头文件`algorithm`中；数值泛型算法在头文件`numeric`中定义
- 泛型算法操作迭代器
- 标准库中使用`begin`和`end`函数获得数组的迭代器
- 算法依赖于元素类型的`==`和`<`操作



## 10.2 初识泛型算法

- 除少数例外，标准算法都是对**范围内的元素进行操作**

### 只读算法

- `find`，`count`，`accumulate`
- `accumulate`前两个参数时迭代器，界定范围；第三个参数是**累加初始值**，参数类型必须与元素类型匹配，或者能转换为第三个参数的类型
- 对`accumulate`算法，第三个参数不能是`const char*`类型，即字面值类型，因为不能保存结果。头文件**numeric**中
- `equal`确定序列相等；第1、2个参数确定第一个序列范围，第3个参数是第二个序列首元素。假定第二个序列长度与第一个一样长

### 写容器算法

- 需要确保序列原大小至少不小于我们要求算法写入的元素数目
- `fill`的第1、2参数用迭代器表示范围，第3个参数为写入的值
- `fill_n`第1个参数表示开始元素，第2个参数是个数，第3个参数为写入的值
  - 重置所有元素：`fill_n(v.begin(), v.size(), 0)`
  - 不能在空容器上调用`fill_n`；例如向空迭代器写入10个元素：`fill_n(v.begin(), 10, 0)`
- `back_insert`定义在**iterator**头文件中；得到**插入迭代器**
  - 插入迭代器是添加元素的迭代器
  - 利用`fill_n`向空容器添加10个元素：`fill_n(back_itsert(v), 10, 0)`
  - 等价于每次赋值都向`v`上调用`push_back`
- 拷贝算法
  - `copy()`：参数1和参数2表示原目标的一对迭代器；参数3是目标的起始地址；返回目标的尾后元素
  - `replace`：参数1和参数2表示输入序列范围；参数3为查找数值；参数4是替代数值
  - `replace_copy`：参数1和参数2表示输入序列范围；参数3是**插入迭代器；参数4为查找数值；参数5是替代数值

### 重排元素的算法

- `sort`函数利用运算符`<`实现排序；
- `unique`获得不重复元素，返回不重复元素的尾后迭代器；但容器中元素个数不变，需要容`erase`删除
- 算法对迭代器操作，所以不能直接添加或删除元素。



## 10.3 定制操作

- 默认情况，算法使用元素类型的`<`和`==`运算符完成比较
- 标准库允提供自己定义的操作来代替默认运算符

### 向算法传递函数

- 谓语是一个可调用的表达式，其返回结果是要给能用作条件的值
- **一元谓语**接受单一参数；**二元谓语**接受两个参数
- 一些算法的重载接受谓语；例如`sort`
- `stable_sort`算法是稳定排序，维持相等元素的原有顺序
- `partition`算法；当谓语为`true`时将元素排在容器的前半部分，否则将元素放后半部分；返回指向最后为为`true`之后的元素

### lambda表达式

- lamda表达式为了突破算法对**谓语的实参个数的限制**
- `find_if`算法查找特定大小的元素，第三个参数是**一元谓词**；返回第一个使谓词非0的元素，如果不存在则返回尾后迭代器。
- **一元谓词**只能传递一个实参
- 算法可以传递任何类别的**可调用对象**
- **可调用对象**是可以使用调用符号的对象或者表达
- 到目前学过的可调用对象：函数、函数指针、**lamda表达式**
- **lamda表达式**表示一个可调用的的代码单元；可以理解为一个未命名的内联函数。
- lamda表达式形式：
  - `[capture list] (paramter list) -> return type {function body}`
  - `capture list`是捕获列表，是lambda所在函数中定义的**局部变量**，**通常为空**
  - `paramter list`，`return type`，`function type`与任何普通函数一样，表示参数列表，返回值，函数体
  - **区别**：返回值必须使用**尾置返回**
  - 参数列表和返回值可以**忽略**，参数列表忽略时为空，返回值根据`return`语句推断出类型
  - 捕获列表和函数体**不能忽略**；捕获列表可以为空，只有**中括号**；
- lamda表达达式不能使用**默认参数**
- 捕获列表为空，表示函数里不使用局部变量；通过捕获列表传递更多的**谓语**
- `for_each`算法，接受一个可调用对象，并对输入序列中每个元素调用此对象

### lambda捕获和返回值

- 定义lambda时，编译器生产一个未命名的新的**类类型**
- 函数传递lambda时，同时定义一个**新的类类型**和**该类型的未命名对象**
- 从lambda生成的类都包含一个对应lambda所捕获的变量的数据成员；在lambda对象创建时被初始化
- **变量的捕获方式**：（1）值；（2）引用
- 值捕获的方式：`[names]`；names是逗号分隔的名字列表；要求变量是可拷贝的
- 引用捕获方式：值捕获的名字列表的名字前加`&`
- 隐式捕获：根据lambda函数体代码推断捕获哪些变量
  - `[=]`：表示隐式值捕获
  - `[&]`：表示隐式引用捕获
- 混合捕获：隐式捕获+显示捕获；隐式捕获的`=`或者`&`必须在中括号的最前
  - 例如：`[=, identifier_list]`；隐式捕获使用值捕获，显示捕获根据list的情况
  - 例如：`[&, identifier_list]`；隐式捕获使用引用捕获，显示捕获根据list的情况
- 可变lambda
  - 对于值被拷贝的变量，lambda不改变其值；通过在参数列表首加上关键字**mutable**使得值捕获变量可以改变数值
  - 引用捕获能否改变变量，取决于引用的是`const`还是非`cosnt`类型；
- `transform`算法接受三个参数，第1、2参数为迭代器，表示输入序列范围；第3参数为目的首地址；接受一个lambda谓语
- lambda体包含`return`语句之外的语句，编译器**推断返回类型是void**
- lambda返回类型通过尾置返回类型

### 参数绑定

- 一个操作需要很多语句才能完成时，通常使用函数更好

- lambda表达式的捕获列表为空，则可以用函数来替代它

- 当lambda表达公式的捕获列表不为空，则使用`bind`函数绑定参数

  - 一般形式：`auto newCallable = bind(callable, arg_list)`
  - `arg_list`中可能包含形如`_n`的名字，其中`n`是一个整数，是占位符
  - 例子，捕获列表被绑定，参数通过占位符绑定

  ```C++
  //lambda
  auto wc = find_if(words.begin(), words.end(),
                   [sz](const string &a));
  //替换为
  auto wc = find_if(words.begin(),words.end(),
                   bind(check_size, _1, sz))
  ```

- 占位符的声明空间：`using std::placeholders`

- 重排调用给你参数顺序

```C++
// f的第1，2，4参数分别被绑定到a, b, c的数值
auto g = bind(f, a, b, _2, c, _1);
// 调用绑定后的函数g
g(X, Y);
// 等价的调用f参数
f(a, b, Y, c, X);
```

- 绑定引用参数
  - 默认情况，`bind`的占位符的参数**被拷贝**到`bind`返回的可调对象中；
  - **ref()**函数，返回对象的引用；**cref()**函数，返回`const`引用的对象；
  - 上述函数定义在**functional**头文件中



## 10.4 再探迭代器

- **定义在头文件`iterator`中**

### 插入迭代器

- 插入迭代器是一种迭代器适配器；使用容器操作来向给定容器的指定尾置插入元素
- 插入迭代器赋值，相当于是再相关位置插入元素；插入位置与插入迭代器类型有关
  - **back_inserter**：调用容器的`push_back`操作插入元素
  - **front_inserter**：调用容器的`push_front`操作插入元素，元素总是插入到容器第一元素之前
  - **inserter**：调用容器的`insert`操作插入元素，元素插入的当前元素之前
- 插入迭代器合法操作，但返回迭代器本身：`*it`，`++it`，`it++`
- 容器是否支持某种插入器迭代器，与该容器是否支持插入迭代器对应的容器操作有关

### 流迭代器

- 遍历关联的IO流

- **istream_iterator**：读取输入流

  - 支持的操作

    - `istream_iterator<T> in(is);`
      - `in`从输入流`is`读取类型为`T`的值
      - 例子
        - `in`从标准输入流`cin`读取类型为`int`的值：`instream_iterator<int>  in(cin);`
        - 定义文件输入流，从文件中读取字符串：`ifstream in("afile"); instream_iterator<string> str_it(in);`
    - `istream_iterator<T> end;`
      - 空的输入流迭代器可以单座尾后迭代器使用
      - 一旦迭代器关联的流遇到文件尾，或者遇到IO错误，迭代器的值等于尾后迭代器
    - `==`，`!=`：相等操作，两者必须是**读取相同类型的**
    - `*in`：解引用返回六种读取的值
    - `in->mem`：与`(*in).mem`的含义相同
    - `++in`：使用元素类型定义的`>>`运算符从输入流中读取下一个值，返回指向递增后迭代器的引用
    - `in++`：使用元素类型定义的`>>`运算符从输入流中读取下一个值，返回原迭代器数值

  - **istream_iterator**最有价值的地方

    ```C++
    istream_iterator<int> in_iter(is), eof;	//从cin读取int类型
    vector<int> vec(in_iter, eof);// 从迭代器范围构造vec，即从cin中读取数据，直到遇到文件尾或者不是int的数据为止
    ```

  - 输入流迭代器在绑定时，不保证迭代器立即读取数据；保证在第一次解引用迭代器前，从流中读取数据的操作已经完成

- **ostream_iterator**：向一个输出流写数据

  - `ostream_iterator`必须半丁到一个指定的流，不能为空或表示尾后位置的
  - 支持的操作
    - `ostream_iterator<T> out(os);`
      - `out`将类型为`T`的值写到输出流`os`中
    - `ostream_iterator<T> out(os, d);`
      - `out`将类型为`T`的值写到输出流`os`中，每个值后面输出一个`d`；`d`为一个C风格字符串
    - `ou t = val`：使用`<<`运算符将`val`写入到`out`绑定的`ostream`中。`val`的类型必须与`out`可写的类型兼容
    - 合法，但无效，返回`out`的操作：`*out`，`++out`，`out++`

### 反向迭代器

- 从尾元素向首元素反向移动的迭代器（reverse_iterator）
- 容器的`crbegin()`表示最后一个元素；`crend()`表示第一个元素之前的元素
- 具有反向迭代器的对象
  - 具有`++`和`--`操作的迭代器定义反向迭代器
  - `forward_list`和流迭代器不具有`--`操作，不具有反向迭代器
- 使用反向迭代器的`base`成员函数，获得该反向迭代器对应的正常迭代器

### 移动迭代器

- 迭代器不是拷贝其中的元素，而是移动他们



## 10.5 泛型算法结构

- 算法要要求的迭代器：输入迭代器，输出迭代器，前向迭代器，双向迭代器，水机访问迭代器
- 五种迭代器支持的操作：
  - 输入迭代器 : `==`,`!=`,`++`,`*`,`->`
  - 输出迭代器 : `++`,`*`
  - 前向迭代器 : `==`,`!=`,`++`,`*`,`->`
  - 双向迭代器 : `==`,`!=`,`++`,`--`,`*`,`->`
  - 随机访问迭代器 : `==`,`!=`,`<`,`<=`,`>`,`>=`,`++`,`--`,`+`,`+=`,`-`,`-=`,`*`,`->`,`iter[n]`==`*(iter[n])`
- 算法形参模式
  - `alg(beg, end, other args)`
  - `alg(beg, end, dest, other args)`
  - `alg(beg, end, beg2, other args)`
  - `alg(beg, end, beg2, end2, other args)`
- 算法结接受传递一个谓词作为`<`和`==`d suanfa 
- _if算法接受一个谓词，例如find查找一个具体数值的位置，find_if查找使谓语不为0的元素
- _cocy后缀区别是不是拷贝结果



## 10.6 特定容器算法

- list、forward_list算法有谢谢链表版本算法
- splice算法是链表数据结构特有的

