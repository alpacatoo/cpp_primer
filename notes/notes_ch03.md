# 第3章 字符串、向量和数组

## using 声明

- using声明的的形式：using *namespae::name*
- 意义：使用namespace空间的中name，例如`using std::cin`表示使用`std命名空间`中的`cin`
- 头文件按不应包含using声明，不然可产生名字冲突



## 标准库类型String

- String表示可变长的字符序列
- `#include <String>`包含头文件后，使用`using std::string;`

### 定义和初始化string对象

- 初始化string对象

| 形式                  | 解释                                              |
| --------------------- | ------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是一个空串                        |
| `string s2(s1)`       | `s2`是`s1`的副本                                  |
| `string s2 =s1`       | 等价于`s2(s1)`，`s2`是`s1`的副本                  |
| `string s3("value")`  | `s3`是字面值“value”的副本，除了最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值“value”的副本    |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串          |

- 拷贝初始化（copy initialization）：使用等号初始化一个变量
- 直接初始化（direct initialization）：使用括号给对象赋值
- `string s8 = string(10, 'c')`：使用直接初始化产生一个**临时对象**，然后将临时对象拷贝初始化`s8`

### string对象的操作

- string对象的操作方式

| 操作                 | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `os << s`            | 将`s`写到输出流`os`中，返回`os`                              |
| `is >> s`            | 从输入流`is`中读取字符串赋值给`s`，字符串以空白符分隔，返回`is` |
| `getline(is, s)`     | 从输入流`is`中读取一行赋值给s，返回`is`                      |
| `s.empty()`          | `s`为空串返回`true`，否则返回`false`                         |
| `s.size()`           | 返回`s`中字符的个数                                          |
| `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从`0`计起                 |
| `s1+s2`              | 返回`s1`和`s2`连接后返回的结果                               |
| `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1==s2`             | 若`s1`和`s2`中所含字符完全一样，则它们相等；且对字符大小敏感 |
| `s1!=s2`             | 同上，结果与`s1==s2`相反                                     |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序比较，大小写敏感                       |

- `>>`读取string：自动忽略开头的空白（即空格符、换行符、制表符等），从第一个字符开始读起直到遇到下一处空白为止
- `getline`读取一行：保留开头的空白，直到遇到换行符。**换行符也被读入，但不被保存到string对象**
- `s.size()`函数返回的数据类型：`string::size_type`
- 字符串`<`, `<=`, `>`, `>=`比较
  - string对象的比较结果，是第一个**相异字符比较的结果**
  - 当一个string对象较短，且结束时**无相异字符**，则较短string对象**小于**较长string对象
- 字面值和string对象相加
  - 运算符`+`两侧的运算对象**至少**有一个`string`对象
  - 两者相加的结果是一个`string`对象。
  - 字符串字面值与`string`是**不同的类型**

### 处理string对象中的字符

- C语言标准库`ctype.h`在C++语言标准库中命名为`cctype`
  - C++标准库将C标准库中头文件的`.h`去除，然后在文件名前增加字符`c`

| 函数          | 解释                          |
| ------------- | ----------------------------- |
| `isalnum(c)`  | 当`c`是字母或数字时为真       |
| `isalpha(c)`  | 当`c`是字母时为真             |
| `iscntrl(c)`  | 当`c`是控制字符时为真         |
| `isdigit(c)`  | 当`c`是数字时为真             |
| `isgraph(c)`  | 当`c`是不是空格但可打印时为真 |
| `islower(c)`  | 当`c`是小写字母时为真         |
| `isprint(c)`  | 当`c`是可打印字符时为真       |
| `ispunct(c)`  | 当`c`是标点符号时为真         |
| `isspace(c)`  | 当`c`是空白时为真             |
| `isupper(c)`  | 当`c`是大写字母时为真         |
| `isxdigit(c)` | 当`c`是十六进制数字时为真     |
| `tolower(c)`  | 将`c`转换为对于的小写字母     |
| `toupper(c)`  | 将`c`转换为对于的大写字母     |

- 使用范围for语句遍历字符串中的字符：`for (auto c : str)`，变量`c`是每个字符的一个拷贝
- 使用引用改变字符串的字符：`for (auto &c : str)`，对变量`c`操作就是对`str`中的字符操作
- 下标运算符（[ ]）随机访问某个字符



## 标准库类型vector

- 标准库类型vector表示**对象的集合**，其中所有对象的类型相同，也常被称作**容器（container）**
- `#include <vector>`，然后`using std::vector;`
- vector是一个类模板，编译器根据该模板**实例化（instantiation）**一个类
- 在模板名字后面跟一对尖括号并写入类型来完成实例化；例如：`vector <int>`表示实例化出一个类型
- vector容纳**对象**作为元素，所以不存在包含引用的vector

### 定义和初始化vector对象

| 形式                             | 解释                                                        |
| -------------------------------- | ----------------------------------------------------------- |
| `vector <T> v1`                  | `v1`是一个空`vector`，它潜在的元素是T类型的，执行默认初始化 |
| `vector <T> v2(v1)`              | `v2`中包含有`v1`所有元素的副本，                            |
| `vector <T> v2 = v1`             | 效果等价于`v2(v1)`                                          |
| `vector <T> v3(n, val)`          | `v3`包含了`n`个元素，每个元素的值都是`val`                  |
| `vector <T> v4(n)`               | `v4`包含了n个元素，每个元素执行了值初始化对象               |
| `vector <T> v5{a, b, c, ...}`    | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值      |
| `vector <T> v5 = {a, b, c, ...}` | 效果等价于`v5{a, b, c, ...}`                                |

- 拷贝初始化化时，两个vector的类型（即T）必须相同
- 列表初始化：用花括号包围，设置元素初始值
- vector支持值初始化，只指定元素个数，初始值由vector类型（即T类型）决定初始值；此时，vector类型必须支持默认初始化。int类型初始化0，string类型初始化为空串

### 向vector中添加元素

- `v.push_back(obj)`是向名为`v`的vector对象末尾添加`obj`对象来增加一个元素
- 使用范围for循环时，不应该改变vector对象的大小

### 其他vector操作

| 操作                  | 解释                                                         |
| --------------------- | ------------------------------------------------------------ |
| `v.empty()`           | `v`中不含有任何元素返回真，否则返回假                        |
| `v.size()`            | 返回`v`中元素的个数                                          |
| `v.push_bakc(t)`      | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`                | 返回`v`中第`n`个位置上元素的引用，从`0`开始计起              |
| `v1 = v2`             | 用`v2`中元素的拷贝替换`v1`中的元素                           |
| `v1 = {a, b, c, ...}` | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`            | 当且仅当`v1`和`v2`中的元素个数和对应位置的元素值相等时，认为`v1`和`v2`相等 |
| `v1 != v2`            | 同上                                                         |
| `<`. `<=`, `>`, `>=`  | 以字典序比较                                                 |

- vector对象的类型总是包含元素的类型
  - `v`的类型为`vector<int>`类型时，`v.size()`返回的大小的类型为`vector<int>::size_type`
- 关系运算符字典序比较
  - vector对象大小关系，由第一对相异的元素值的大小决定
  - 元素较少vector对象结束时，也没有相异的元素值，则较元素较少vector对象小于元素较多vector对象
  - **只有当元素的值可比较时，vector对象才可以比较**
- **不能使用下表形式来添加元素**，下表运算符只可用于访问已存在的元素



## 迭代器介绍

- `string`对象的字符和`vector`对象的元素既可以使用**下标**范文，也可以使用**迭代器**访问
- 所有标准库容器都可以使用迭代器，但只有少数支持下表运算符
- 类似于指针类型，迭代器也提供了对对象的间接访问

### 使用迭代器

- `v.begin()`返回`v`中第一个元素的迭代器
- `v.end()`返回`v`中尾元素的下一个位置，常称为**尾后迭代器**
- 迭代器运算符

| 运算符           | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `*iter`          | 返回迭代器`iter`所指元素的引用                               |
| `iter->men`      | 解引用`iter`并获取该元素的名为`mem`的成员，等价于`(*iter).mem` |
| `++iter`         | 令`iter`指向容器中下一个元素                                 |
| `--iter`         | 令`iter`指向容器中上一个元素                                 |
| `iter1 == iter2` | 迭代器指向相同元素，或者均指向尾后迭代器，则相对             |
| `iter1 != iter2` | 反之，不相等                                                 |

- 试图解引用一个非法迭代器或者尾迭代器都是未定义的行为
- `v.end()`返回的迭代器并不实际指示某个元素，所以不能对其进行**递增**和**解引用**
- `v.begin()`和`v.end()`返回的迭代器类型：
  - `v`对象不是常量，则返回的迭代器类型是`vector<int>::iterator`
  - `v`对象是常量，则返回的迭代器类型是`vector<int>::const_iterator`
- 当`v`对象只需要读操作，不需要写操作，只需要`const_iterator`类型
  - 通过`v.cbegin()`返回第一个元素的`const_iterator`类型迭代器
  - 通过`v.cend()`返回`const_iterator`类型尾后迭代器

### 迭代器运算

| vector和string支持的运算 | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `iter + n`               | 迭代器加上一个整数仍得一个迭代器。<br />迭代器指示的新位置比原位置向前移动`n`个位置。<br />结果迭代器或者指示容器内的一个元素，或者指示尾元素的下一个位置。 |
| `iter - n`               | 迭代器减去一个整数仍得一个迭代器。<br />迭代器指示的新位置比原位置向后移动`n`个位置<br />结果迭代器或者指示容器内的一个元素，或者指示尾元素的下一个位置。 |
| `iter1 += n`             | 迭代器加法的复合语句，将`iter1`加`n`的结果赋值给`iter1`      |
| `iter1 -= n`             | 迭代器减法的复合语句，将`iter1`减`n`的结果赋值给`iter1`      |
| `iter1 - iter2`          | 两个迭代器相减的结果是他们之间的距离。                       |
| `<`, `<=`, `>`, `>=`     | 迭代器指向的位置在另一个迭代器所指位置之前，则说前者小于后者 |

- 迭代器减法的结果的类型：`difference_type`



## 数组

- 数组的大小确定不变，运行时性能最好

### 定义和初始化数组

- 声明形式：`a[d]`，其中`a`是数组的名字，`d`是数组的维度

- 维度说明了数组中元素的个数，元素的个数也属于数组类型的一部分

- 编译时维度已知，故维度必须是一个常量表达式

- 定义数组时不允许使用`auto`关键字由初始值推断数组类型

- 数组初始化

  - 可以使用列表初始化数组，要求维度`d`需要大于列表元素个数；数组靠前部分根据列表数值初始化，剩余元素被初始化成默认值
  - 定义数组时，若使用列表初始化数组，可以不指明维度，维度数值为列表元素的个数

  ```C++
  int ia1[4] = {0, 1, 2, 3};	//前三个元素按照列表元素值初始化，第四个元素设置为默认值
  int a[]={0,2};				//数组a根据列表中元素个数推断得到维度为2
  ```

- 数组指针与指针数组

  - 类型修饰符从右往左依次绑定，对于数组而言，就是**由内往外**；不存在**引用的数组**

```C++
int *ptrs[10];		//ptrs时含有整型指针(int*)的数组
int &refs[10];		//不存在
int (*Parray)[10];	//Parray指向一个含有10个整数的数组
int (&arrRef)[10];	//arrRef引用一个含有10个整数的数组
int *(&R=array)[10];	//array是数组的引用，给该数组含有10个指针
```

### 访问数组元素

- 数组下标的类型：`size_t`

### 指针和数组

- 在很多用到数组名字的地方，编译器自动替换为一个**指向数组首元素的指针**
- `auto`关键字通过数组名推断获得的类型是指针而非数组，当使用`decltype`推断获得的类型是数组类型
- 在`iterator`头文件中，定义有`begin()`和`end()`函数，分别返回数组的首元素指针，和数组尾后指针
- 指针相减结果的类型为`ptrdiff_t`类型，在`cstddef`头文件中定义
- 下标和指针
  -  当`int *p = a`时，即`p`指向数组`a`首元素，则`*(P+2)`等价于`a[2]`
  - 标准库的下表必须是**无符号数值**，内置下标运算无此要求；例如，当`int *p = &a[2]`时，则`p[-2]`表示数组`a`的首元素

### C风格字符串

- C风格字符串存放在字符数组里并以**空字符结束**
- C风格字符串的函数定义在`cstring`头文件里

| 函数             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性，相等返回0，`p1>p2`,返回正值，`p1<p2`返回负值 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`；`p1`的大小必须大于两个叠加后的大小 |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

- 使用string类型对象比较安全
- 获取string中的cstring：`cosnt char *str = s.c_str();`
- 若要一直使用`c_str()`函数的返回值，最好将该数组重新拷贝一份
- **使用数组初始化vector对象**：`vecor<int> ivec(begin(int_arr), end(int_arr));`



## 多维数组

- C++中没有多维数组，通常数的多维数组其实是**元素是数组的数组**
- 多维数组定义，例如，定义大小为3的数组，每个元素是4个整数的数组：`int ia[2][4];`
- 对于二维数组来书，第一个维度称为行，第二个维度称为列
- 多维数组初始化

```C++
//初始化方式1
int ia[3][4] = {	//三个元素，每个元素是大小为4的数组
    {0, 1, 2, 3},	//第一行初始化
    {4, 5, 6, 7},	//第二行初始化
    {8, 9, 10, 11}	//第三行初始化
};
//初始化方式2
int ia[3][4] = {{0}, {4}, {8}};	//初始化每行的首元素，其他元素默认值初始化
//初始化方式3
int ia[3][4] = {0, 1, 2, 3, 4};	//按照第1行1列，第1行2列，...，第n行n列排列，列表数值讲前端元素初始化，剩余部分默认值初始化
								//因此，第一行的4个元素被初始化，第2行第1列的元素被初始化为4
```

- 多维数组的下标引用
  - 引用`ia`s数组的第二行：`int (&row)[4] = ia[1]`，其中`ia`定义为：`int ia[3][4]`
  - 范围for循环遍历多维数组，除最内层for循环，其他循环控制变量需要使用**引用类型**；因为**编译器会将数组自动转换为指针造成内层循环不合法**
- 指针和多维数组

```C++
int ia[3][4];
int (*p)[4];
p = &ia[2];					//p指向最后一行
using int_array= int[4];
typedef int int_array[4];
int_array *p = &ia[2]		//定义p，p的基础类型是4个元素的int数组
```

