# 第6章 函数

- 函数是一个命名了的代码块；可以有0个或多个参数数；可以被重载



## 函数基础

- 函数定义的组成：返回类型、函数 名字、0个或多个形参、函数体
- 执行函数
  - 通过**调用运算符**来执行函数；调用运算符是一对圆括号；括号之内是用**逗号**隔开的实参；
  - 函数调用完成的工作：（1）实参初始化对应的形参；（2）主调函数的执行被中断，控制权转移给被调函数
  - 函数遇到一条`return`语句时函数结束执行过程
  - 函数结束完成的工作：（1）返回`return`语句中的值（如果有的话）；（2）控制权从被调函数移回主调函数
- 实参与形参对应，但没规定**实参的求值顺序**
- 形参列表
  - 形参以逗号隔开，位于圆括号之内
  - 形参列表可以为空，但不能省略；也可以使用使用关键字`void`表示空形参列表
  - 即使两个形参类型一样，也必须把两个类型都写出来
- 返回类型不能是**数组类型或函数类型**，但可以是指向**数组或函数的指针**

### 局部对象

- 名字有作用域，对象有生命周期
- 局部变量：形参和函数体内定义的变量；在函数作用域内可见，隐藏外层作用域中同名的其他所有声明
- 自动对象：只存在于块执行期间的对象；形参是一种自动对象
- 局部静态变量：`static`修饰的局部变量，在程序执行路径第一次经过对象定义语句时初始化；**内置类型的局部内部静态变量默认值初始化为0**

### 函数声明

- 函数名在使用前声明；函数声明又称为**函数原型**；若没有使用函数，则可以只有声明没有定义
- 函数声明与函数定义的区别：
  - 函数声明无须函数体，用一个分号代替
  - 函数声明形参列表可以没有形参名字，但必须有形参类型
- 函数在头文件中声明，在源文件中定义；函数定义的源文件必须包含函数声明的头文件（为了让编译器验证函数定义和声明是否匹配）

### 分离式编译

- 每个文件独立编译，产生包含对象源码的`.obj`文件或`.o`文件
- 编译器再负责把对象文件链接在一起，形成可执行代码



## 参数传递

- 形参**是**引用类型，形参将被绑定到对应实参上；实参被**引用传递**；或者称函数被**传引用调用**
- 形参**非**引用类型，将实参的值拷贝后赋值形参；实参被**值传递**；或者称函数被**传值调用**

### 传值参数

- 对形参的改动，不会影响实参
- 指针形参拷贝的是指针的值，即拷贝地址，两个指针是不同的指针
- C++中，**建议使用引用类型的形参替代指针**

### 传引用参数

- 使用引用避免拷贝；如果函数无需改变引用形参的值，最好将其声明为**常量引用**
- 引用形参为我们一次返回多个结果提供了有效的途径

### 数组形参

- 不允许拷贝数组；使用数组时通常会将其转化为指针
- 无法以值床底的方式使用数组参数；为函数传递数组时，传递的是指向数组首元素的指针
- 传递数组形参

```C++
void print(const int*);		//三个函数都有一个const int*类型的形参
void print(const int[]);	//这个可以看出是一个数组
void print(const int[10]);	//实际元素个数不一定是10个
```

- 管理数组形参的三种方式：

  - 数组本身包含一个**结束标记**，例如，C语言风格字符串存储在数组中，以空字符为结束标志 
  - 传递指向数组**首元素和尾后元素的指针**
  - 定义一个表示数组大小的形参，例如，数组大小的size

- 数组引用形参，注意`&arr`两端的括号必不可少；少了就变成了引用的数组
```C++
void print(int (&arr)[10]){ /* ... */}	//引用维度为10的数组
```
- 传递多维数组：

  - 多维数组其实就是数组的数组
  - 指针语法形式：形参传递指向数组首元素的形参；首元素是指向数组的指针；`*matrix`两端的括号不能少

  ```C++
  void print(int (*matrix)[10], int rowSize){/* ... */} 
  ```

  - 数组语法形式：声明看起来是一个二维数组，**实际上形参是指向含有10个整数的数组的指针**

  ```C++
  void print(int matrix[][10], int rowSize){/* ... */} 
  ```

### mian处理命令行选项

- 命令行通过`argc`和`argv`两个可选形参传递给main函数
- `argv`是一个数组，元素是指向**C语言风格字符串的指针**；`argv[0]`是程序名或者为空字符串；其他元素是命令行参数
- `argc`表示数组的大小，即字符串的数量；
- main函数的定义
  - 方式一：`int main(int argc, char *argv[]){ ... }`
  - 方式二：`int main(int argc, char **argv){ ... }`

### 含有可变形参的函数

- 编写处理不同数量形参的函数
  - 方式一：`initializer_list`标准库类型；要求实参类型相同
  - 方式二：可变参数模板；实参类型可以不同
  - 方式三：**省略符形参类型**，一般用于与C函数交换的接口程序
- `initializer_list`形参
  - 定义函数：`return_type function_name( initializer_list<Type> parameter_name)`
  - 调用函数：`functionname({var1,var2,...,varn})`
  - `initializer_list`也是要给模板类型，需要给定基本类型；其元素都是**常量值**
  - 调用函数时，形参序列要放在花括号中
  - 含有`initializer_list`形参的函数也可以同时拥有其他 形参，例如，`void error_msg(Errcode e, initializer_list<string> il){ ... }`
  - `initializer_list`包含`begin`和`end`成员，可以使用范围for循环
- 省略符形参
  - 使用了`varargs`的C标准库功能
  - 省略符只能出现哎形参泪飙的**最后一个位置**
  - 形式一：`void foo(parm_list, ...)`
  - 形式二：`void foo(...)`
  - 省略符形参**无需类型检查**



## 返回类型和return语句

- `return`语句的功能：终止指向函数并将控制权返回到调用该函数的地方
- `return`语句的两种形式

```C++
return;
return expression;
```

### 无返回值函数

- 无返回值的`return`语句只能用在返回值为`void`的函数中
- 返回类型为`void`的函数可以没有`return`语句，函数最后会**隐式**添加

### 有返回值函数

- 有返回值的`return`语句返回的值用于初始化调用点的一个临时变量，该临时量就是函数调用的结果
- 返回类型都可以是引用类型；但注意不要返回局部变量的指针或引用
- 返回引用的函数得到左值，其他返回类型得到右值；我们能为返回类型是非常量引用的函数的结果赋值
- **函数可以返回花括号包围的值的列表**

  - 返回内置类型，列表离最多包含一个值，且该值所占空间不大于目标类型空间
  - 返回类类型，由类本身定义初始值如何使用
- main函数若没有`return`语句，编译器自动插入一天`return 0;`语句；
- main函数可以通过返回`cstdlib`头文件内的`EXIT_SUCCESS`和`EXIT_FAILURE`预处理变量表示成功和失败

### 返回数组指针的函数

#### 一般方法

- 维度必须更在函数名字之后；形参列表也在函数名字之后且应该先于数组的维度

```C++
Type (*function(parameter_list))[dimension]
```

- 以`int (* func(int i))[10]`为例按顺序理解声明的含义：
  - `func(int i)`表示调用`func`函数时传递`int`类型的实参
  - `(* func(int i))`表示对调用函数返回结果进行**解引用操作**
  - `(* func(int i))[10]`表示解引用函数调用得到一个大小为10的数组
  - `int (* func(int i))[10]`表示数组元素的类型是`int`类型

#### 使用**尾置返回类型**

- 任何函数的定义都可以使用尾置，但对形式比较复杂的返回类型比较有效，比如数组指针或数组引用
- 以`int (* func(int i))[10];`为例

```C++
auto func(int i) -> int(*)[10];
```

- 以`int func(int i);`为例

```C++
auto func(int i) -> int;
```

#### 使用**decltype关键字**

- 使用场景：直到函数返回的指针将指向哪个数组

```C++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i)
{
    retunr (i%2) ? &odd : &event;
}
```

- `decltype`的结果是一个数组，要表示指针必须在**函数声明时加一个*符号**



## 函数重载

- 函数重载：**同一作用域**内几个**函数名字相同**但**形参列表不同**
- 参数列表的不同体现在形参的**数量**或**类型**；不允许两个函数除**返回类型**外其他所有要素都相同

### 函数不是重载的几种情况

- 省略形参名：形参名字仅起到记忆作用，不影响形参列表的内容，例如下边两个函数相同

```C++
Record lookup(const Account &acct);
Record lookup(const Account &);
```

- 类型别名：已存在类型的另一个名字，类型仍是一样的；例如下边两个函数相同

```C++
typedef Phone Telno
Record lookup(const Phone &);
Record lookup(const Telno &);
```

- **顶层const**：不影响传入函数的对象，无法区分拥有顶层cosnt的形参和另一个没有顶层const的形参；

```C++
Record lookup(Phone);
Record lookup(const Phone);		//重复声明Record lookup(Phone);
Record lookup(Phone*);
Record lookup(Phone* const);	//重复声明Record lookup(Phone*);
```

### 底层const可以实现重载函数

- 情景：形参是指针或引用
- 底层const可以区分函数

```C++
Record lookup(Account&);		//作用于Account的引用
Record lookup(const Account&);	//新函数，作用于常量引用
Record lookup(Account*);		//新函数，作用于指向Account的指针
Record lookup(const Account*);	//新函数，作用于指向常量的指针
```

- `cosnt`对象不能转换成其他类型，只能把`const`对象传递给`const`形参
- 非常量可以转换为`const`，但根据最佳匹配，编译器会优先选用非常量版本的函数

### const_cast和重载

- 形参和返回值都是`const string`引用的函数

```C++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

- 两个非常量的`string`实参也可以调用这个函数，但返回结果仍然是`const string`的引用；为得到普通引用，使用`cosnt_case`

```C++
string &shorterString(string &s1, const string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
                            const_cast<const strung&>(s2));
    retunr const_cast<string&> (r);
}
```

### 调用重载函数的三种结果

- 最佳匹配
- 无匹配
- 二义性调用

### 重载与作用域

- 外层作用域无法重载函数
- 在当前作用域匹配函数，优先使用类型转换



## 默认实参

- 形参列表中某一个形参被赋予了默认值，它后面的所有形参都必须有默认值
- 函数调用时按照其位置解析
- 在给定的作用域中一个形参只能被赋予一个默认实参；即后续声明只能为没有默认值的形参添加形参
- 通常在函数声明中添加默认形参，并放在合适的头文件中
- **表达式可以作为默认形参**，局部变量不会作为默认形参；表达式求值发生在函数调用时。



## 内联函数

- 关键字`inline`将函数声明为内联函数
- 内联说明只是向编译器请求，编译器可以忽略；比如不支持内联递归函数
- 定义通常放在头文件中



## constexpr函数

- 只能用于常量表达式的函数
- 函数的返回类型及所有形参的类型都得是**字面值类型**，函数体中**有且只有一个retrn语句**
- `constexpr`函数被隐式指定为内联函数，编译其将其替换成其结果值
- `constexpr`函数不一定放回常量表达式
- 定义放在头文件中



## 调试帮助

- 两项预处理功能：`assert`和`NDEBUG`
- `assert`预处理宏
  - `assert(expr)`
  - expr为假终止程序，为真什么也不做
  - 在`cassert`头文件中定义预处理宏
- `NDEBUG`预处理宏：定义了`NDEBUG`宏，`assert`什么也不做
- 有用的宏变量
  - `__func__`：当前调试的函数名
  - `__FILE__`：当前调试的文件名
  - `__LINE__`：当前行号
  - `__TIME__`：编译实际
  - `__DATE__`：编译日期



## 函数匹配

- 第一步：确定候选函数，即函数同名，声明在调用点可见
- 第二步：确定可行函数，即从候选函数中选择同时具有两个特征的函数
  - 形参数量与本次调用提供的实参数量相等
  - 每个实参类型与对应实参类型相同，或者能转换为形参类型
  - 具有摩默认实参的函数，可以与不少于无默认实参个数的函数调用匹配
- 第三步：从可行函数中选择最佳匹配
  - 基本思想：实参类型与形参类型越接近，它们匹配的越好
  - 匹配原则：有且只有一个函数满足
    - 每个实参的匹配都不劣于其他可行函数的匹配
    - 至少有一个实参的匹配由于其他可行函数
  - 调用重载函数时尽量避免强制类型转换



## 实参类型转换的等级

（从高到底）

- 精确匹配：（1）实参类型和形参类型相同；（2）数组或函数转换为对应指针类型；（3）顶层cosnt的添加删除
- 通过const转换实现匹配
- 通过类型提升实现匹配
- 通过算数类型转换或指针转换实现匹配
- 通过类类型转换实现匹配



## 函数指针

- 函数的类型由它的返回类型和形参类型共同决定

### 声明函数指针

```c++
//原函数
bool lengthCompare(const string &, cosnt string &);
//用指针替换函数名即可
bool (*p)(const string &, cosnt string &);
//两端括号必不可少，不然该函数就变成返回bool*了
```

### 使用函数指针

- 函数名作为一个值使用时，该函数自动地转换成指针，**取地址符可选**

```C++
pf = lengthCompare;		//两个等价的赋值
pf = &lengthCompare;
```

- 函数指针调用**无需提前解引用指针**

```C++
bool b1 = pf("hello", "goodbye");
bool b2 = (*pf)("hello", "goodbye");
```

- 不同类型函数指针间**不存在类型转换**，但可以赋值nullptr

### 函数指针重载

- 函数指针类型必须于重载函数中的某个**精确匹配**

### 形参是函数指针

- 形参就是函数类型
- 显示将形参定义成指向函数的指针
- 函数名作为实参，会自动转换为指针
- 类型别名和decltype；decltype返回函数类型，不会自动转换成指针，许哟啊手动星号

### 返回值是函数指针

- 方法一：类型别名

```C++
using F = int(int*,int)
using PF = int(*)(int*, int);
PF f1(int);
F *f1(int)	//等价
```

- 方法二：直接声明；由内而外，f1函数，形参是一个`int`数据，返回指针，指向一个函数，函数类型是`int(int*, int)`

```C++
int (*f1(int))(int*, int);
```

- 方法三：尾置返回类型

```C++
auto f1(int) -> int(*)(int*, int);
```

- 方法四：decltype方法，前提知道返回函数类型，并且要加星号

```C++
string::size_type sumLength(const string&, cosnt stirng&);
decltype(sumLength) *getFcn(const string &);
```

