# 第9章 顺序容器

- 容器时一些特定类型对象的集合
- 顺序容器位程序员提供了控制元素存储和顺序访问的能力



## 9.1 顺序容器概述

- 所有顺序容器都提供了快速访问元素的能力
- 不同顺序容器的差别：
  - 向容器添加或从容器中删除元素的代价
  - 非顺序访问容器中元素的代价
- 顺序容器类型

| 容器名         | 功能                       | 支持的访问方式 | 元素添加或删除速度 | 内存分布 |
| -------------- | -------------------------- | -------------- | ------------------ | -------- |
| `vector`       | 可变大小数组               | 快速随机访问   | 尾部操作快         | 连续     |
| `deque`        | 双端队列                   | 快速随机访问   | 头尾位置操作快     | 连续     |
| `list`         | 双向链表                   | 双向顺序访问   | 任何位置操作快     | 分散     |
| `forward_list` | 单向链表                   | 单向顺序访问   | 任何位置操作快     | 分散     |
| `array`        | 固定大小数组               | 快速随机访问   | 不能操作           | 连续     |
| `string`       | 字符串，与vector相似的容器 | 快速随机访问   | 尾部操作快         | 连续     |

- `array`，固定大小，比内置数组更安全、更容易使用的数据类型
- `forward_list`没有`size`操作，为了减少保存计算大小的额外大小，实现最好的手写单向链表数据结构



## 9.2 容器库概览

- 容器操作的层次：
  - 层次1：所有容器都具有的操作
  - 层次2：有些操作仅针对顺序容器、关联容器或无需容器
  - 层次3：有些操作只适用于一小部分容器
- 容器均定义为模板类，需要提供额外信息来生成特定的容器类型
- 顺序容器几乎可以保存任意类型的元素

### 容器类型成员

| 类型别名          | 解释                                           |
| ----------------- | ---------------------------------------------- |
| `iterator`        | 此容器类型的迭代器                             |
| `const_interator` | 只读类型的容器类型的迭代器                     |
| `size_type`       | 无符号整数，能容纳此容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，两个迭代器间距离               |
| `value_type`      | 元素类型                                       |
| `reference`       | 元素的左值类型；与`value_type&`含义相同        |
| `const_reference` | 元素的const左值类型，即`const value_type&`     |

### 容器定义与初始化

- 除`array`之外，其他容器的默认构造函数都会创建一个指定类型的**空容器**，且可以接受指定容器大小和元素初始值的参数。

| 构造函数                                        | 解释                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `C c;`                                          | 默认构造函数，构造空容器；<br />如果`C`是`array`，则`c`中元素按默认方式初始化 |
| `C c1(c2);`<br />`C c1=c2;`                     | 拷贝`c2`，构造`c1`；**两者容器类型和元素类型必须相同**；<br />对于`array`，大小也要相同 |
| `C c{a, b, c, ..};`<br />`C c = {a, b, c, ..};` | 列表初始化`c`；列表元素与C的元素相容；<br />对于`array`类型，还需列表元素个数必须等于或小于`array`的大小 |
| `C c(b, e);`                                    | 构造`c`，将迭代器`b`和`e`之间的元素拷贝到c；**，元素类型可转换**（`array`不支持） |

- 只有顺序容器（不包括array）的构造函数才能接受大小参数

| 顺序容器（除array）独有的构造函数 | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `C seq(n)`                        | `seq`包含n个元素，每个元素进行值初始化；<br />构造函数是`explicit`的（`string`不适用） |
| `C seq(n, t)`                     | `seq`包含`n`个初始化为值`t`的元素                            |

- 容器拷贝范围：（
  - 整个容器全部拷贝；要求**容器类型**和**元素类型**必须一致
  - 迭代器指定范围拷贝：要求**元素类型可转换**，对容器类型和元素类型**可以不同**。
- 定义`array`时，指定类型和容器大小，例如保存10个string元素的数组：`array<string, 10> `
- 定义`array`时，元素会默认初始化，**不会是空容器**；赋值初始化时，除要求元素类型一致，容器大小也必须是一致的

### 赋值与swap

- 赋值运算符将左边容器中的全部元素，体会为右边容器中元素的拷贝
- **array**允许赋值（**与内置数组类型的区别**）；

| 赋值与swap            | 解释                                      |
| --------------------- | ----------------------------------------- |
| `c1 = c2`             | 将c1中的元素替换为c2中元素                |
| `c1 = {a, b, c, ...}` | 将c1中元素替换为列表中元素（array不支持） |
| `a.swap(b)`           | 交换a和b的元素                            |
| `swap(a, b)`          | 交换a和b的元素                            |

- **array**不支持**assign**与使用花括号包含的值列表进行赋值（左右两边array大小可能不同）
- 顺序容器（除array）支持的assign操作

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `seq.assign(b, e)` | 迭代器`b`和`e`表示范围中元素替换`seq`中的元素；<br />迭代器`b`和`e`不能指向`seq`中的元素 |
| `seq.assign(il)`   | 初始化列表`il`中的元素替换`seq`中的元素                      |
| `seq.assign(n, t)` | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

- 除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作；保证在常数时间完成
- 不对容器元素移动，表明**除string外**，指向容器的迭代器、引用和指针在`swap`操作后不会失效。
- 统一使用**非成员版本**`swap`是好习惯

### 容器大小操作

| 大小           | 解释                                 |
| -------------- | ------------------------------------ |
| `c.size()`     | c中元素个数                          |
| `c.max_size()` | c中可保存的最大元素数据              |
| `c.empty()`    | c中存储了元素返回false，否则返回true |

### 关系运算符

| 关系运算符           | 解释                                 |
| -------------------- | ------------------------------------ |
| `==`, `!=`           | 所有容器都支持这两个运算             |
| `<`, `<=`, `>`, `>=` | 关系运算符（**无序关联容器不支持**） |

- 关系运算符两边的运算对象必须是**相同类型的容器**
- 两个容器比较实际上是容器**元素逐对比较**
  - 容器大小和元素都相等，则两个容器相等
  - 容器大小不同，则较小容器小于较大容器
  - 容器的比较结果，取决于第一个不相等元素的比较结果
- 相等运算符通过`==`运算符实现；关系运算符通过`<`运算符实现

### 迭代器

- 所有迭代器通过解引用运算符实现访问容器中的元素
- 迭代器范围由一对迭代器表示，指向同一容器中的元素或者尾后元素
- 迭代器范围是**左闭右开区间**

- 获取迭代器
  - `c.begin()`, `c.end()`：返回指向c的首元素和尾后元素位置的地带其
  - `c.cbegin()`, `c.cend()`：返回`const_iterator`
- 反向容器的额外成员（不支持`forward_list`）
  - `reverse_iterator`：按逆序寻址元素的迭代器
  - `const_reverse_iterrator`：不能修改元素的逆序迭代器
  - `c.rbegin()`, `c.rend()`：返回指向c的尾元素和首元素之前位置的迭代器
  - `c.crbegin()`, `c.crend()`：返回`const_reverse_iterator`

### 容器支持的添加/删除元素（array不适用）

| 添加 / 删除 元素   | 解释                        |
| ------------------ | --------------------------- |
| `c.insert(args)`   | 将args中的元素拷贝进c       |
| `c.emplace(inits)` | 使用inits构造c中的一个元素  |
| `c.erase(args)`    | 删除args指定的元素          |
| `c.clear()`        | 删除c中的所有元素，返回void |

### 

## 9.3 顺序容器的操作

- 所有操作，**array**不支持，由于改变容器大小

### 向顺序容器添加元素

- push_back
  - 不支持的顺序容器：`array`和`forward_list`
  - 支持的顺序容器：`vector`, `list`和`deque`；（还有字符容器`string`）
  - 格式：`c.push_back(t)`；c对象的尾部创建一个置位`t`的元素，返回`void`
- push_front
  - 不支持的顺序容器：`array`, `vector`（还有字符容器`string`）
  - 支持的顺序容器：`list`，`forward_list`和`deque`
  - 格式：`c.push_front(t)`；c对象的首部创建一个置位`t`的元素，返回`void`
- 特定位置添加元素（insert）
  - 不支持的顺序容器：`array`
  - 支持的顺序容器：`vector`，`deque`， `list`（还有字符容器`string`）
  - **特殊版本的insert**：`forward_list`
  - 格式：
    - `c.insert(p, t)`，在迭代器`p`指向的元素**之前**，创建一个值为`t`的元素；返回新添加元素的迭代器
    - `c.insert(p, n, t)`，在迭代器`p`指向的元素**之前**，插入`n`个值为`t`的元素；返回新添加第一个元素的迭代器，`n`为零时返回`p`
    - `c.intert(p, b, e)`，在迭代器`p`指向的元素**之前**，插入`b`和`e`范围内的元素；`b`和`e`不能指向`p`的元素；返回新添加第一个元素的迭代器，范围为空返回`p`
    - `c.inset(p, il)`，`il`是一个被花括号包围的元素值列表；在迭代器`p`指向的元素**之前**，插入列表中的值；返回新添加第一个元素的迭代器，范围为空返回`p`
  - `list`的插入速度快，`vector`，`deque`和`string`的插入耗时
- emplace
  - `emplace_front`，`emplace`和`emplace_back`分别对应`push_front`，`insert`和`push_bakc`；将元素放置在容器头部，一个指定地方和容器尾部
  - `emplace`是**构造**而不是拷贝元素；会在容器管理的空间中直接创建对象；其对应的函数是创建元素类型的**临时对象**后，压入容器中。
  - 由于`emplace`相关函数是在容器中直接构造元素，所以其**实参必须与元素类型**的构造函数相匹配。
  - 顺序容器适配情况
    - `forward_list`具有**专有版本的`emplace`**；不支持`emplace_back`
    - `vector`和`string`不支持`emplace_front`
    - `array`全部不支持

### 访问顺序容器元素

- front函数：所有顺序容器，包括`array`均有，格式：`c.front()`，返回元素内容
- back函数：除`forward_list`之外的所有容器均有，格式：`c.back()`，返回最后一个元素
- `c.front()`等价于`*c.begin()`；`c.back()`等价于`*c.end()`；**`c`为空时，front、back函数行为未定义**
- 下边访问：
  - `c[n]`：返回下标为`n`的元素的引用；`n`为无符号整数，`n`大于`c.size()`则行为未定义
  - `c.at(n)`：返回下标为`n`的元素的引用；越界抛出`out_of_range`异常

### 删除循序容器元素

- 所有删除操作均不支持`array`
- pop_back函数
  - 不支持的顺序容器：`array`，`forward_list`
  - 支持的顺序容器：`vector`，`deque`，`list`，`string`
  - 格式：`c.pop_back()`；删除`c`中尾元素，返回`void`，`c`为空则函数行为未定义
- pop_front函数
  - 不支持的顺序容器：`array`，`vector`，`string`
  - 支持的顺序容器：`list`，`front_list`，`deque`
  - 格式：`c.pop_front()`；删除`c`中首元素，返回`void`，`c`为空则函数行为未定义
- erase函数
  - 不支持的顺序容器：`array`
  - 支持的顺序容器：`vector`，`deque`，`list`，`string`
  - **特殊版本的容器**：`forward_list`
  - 格式：
    - `c.erase(p)`：删除迭代器`p`所指的元素，返回其下一个元素的迭代器；迭代器`p`为尾后迭代器，则函数行为未定义
    - `c.erase(b, e)`：删除迭代器`b`和`e`范围内的元素，返回最后一个被删元素之后元素的迭代器；迭代器`e`为尾后迭代器，则返回尾后迭代器
- `pop_back`和`pop_front`返回**void**，所以在弹出操作前要保存元素
- clear函数
  - 删除容器中所有元素：`c.clear()`
  - 使用`erase`的等价调用：`c.erase(c.begin(), c.end())`

### 特殊的forward操作

- `forward_list`是单向列表，定义了`insert_after`，`emplace_after`和`erase_after`操作；对应其他容器的`insert`，`emplace`和`erase`操作
- 首前迭代器：使得可以在链表首元素之前，并不存在的元素之后添加、删除元素
- `forward_list`中添加或删除元素，关注两个迭代器：（1）要处理的元素；（2）其前驱元素

| 操作                                                         | 解释                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `lst.before_begin()`<br />`lst.cbefore_begin()`              | 返回首前元素<br />`lst.cbefore_begin()`是一个`cosnt_interater` |
| `lst.insert_after(p, t)`<br />`lst.insert_after(p, n, t)`<br />`lst.insert_after(p, b, e)`<br />`lst.insert_after(p, il)` | 在迭代器`p`之后插入元素。<br />`t`是对象，`n`是数量；`b`和`e`是迭代器，表示插入对象的范围区间<br />`il`是花括号列表。返回值是最后一个插入元素的迭代器 |
| `emplace_after(p, args)`                                     | 使用`args`在`p`指定的位置之后创建一个元素。返回指向新元素的迭代器 |
| `lst.erase_after(p)`<br />`lst.erase_after(b, e)`            | 删除迭代器`p`之后的元素，或删除迭代器`b`之后直到`e`之间的元素。<br />返回被删元素之后的迭代器 |

### 改变容器大小

- `array`并不支持
- `c.resize(n)`调整`c`的大小为`n`个元素。多余元素被丢弃
- `c.resize(n, t)`调整`c`的大小为`n`个元素，新添加元素赋值为`t`

### 容器操作可能使迭代器失效

- 插入元素
  - `vector`和`string`
    - 重新分配存储空间：迭代器、指针、引用都失效
    - 未重新分配空间：
      - 插入位置之前的元素：迭代器、指针、引用仍有效
      - 插入位置之后的元素：迭代器、指针、引用都失效
  - `deque`
    - 首、尾位置之外插入元素：迭代器、指针、引用都失效
    - 首、尾位置插入元素：迭代器失效；指针、引用仍可以使用
  - `list`和`forward_list`：指向容器的迭代器、指针、引用仍有效
- 删除元素
  - `list`和`forward_list`：指向容器的迭代器、指针、引用仍有效
  - `deque`
    - 首尾之外位置删除：指向被删除元素外其他元素的迭代器、引用、指针也失效
    - 删除尾元素：尾后迭代器失效
    - 删除首元素
  - `vector`和`string`
    - 被删元素之前：迭代器、引用、指针仍有效
    - 尾后迭代器总失效
- **不要保存end()函数返回的尾后迭代器，或者添加/删除操作后重新赋值**



## 9.4 vector对象是如何增长的

- `vector`将元素连续存放
- `vector`和`string`的实现通常会分配比新的空间需求更大的内存空间
- `vecotr`，`string`、`deque`支持的大小管理操作
  - `c.capacity()`：不重新分配内存空间情况下，`c`可以保存多少元素
  - `c.reserve(n)`：分配至少容纳`n`个元素的**内存空间**；这只是**分配建议**
- `vector`，`string`支持的容器大小管理操作
  - `c.shrink_to_fit()`：将预分配的内存空间大小，设置成与实际元素个数一致。这只是**分配建议，不保证退还内存空间**
- 函数比较

| 函数           | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| `c.size()`     | 容器`c`中元素的格式                                          |
| `c.resize(n)`  | 改变容器`c`中的元素个数；<br />当`n<`c.size`，多余的元素被丢弃；否则，多余的元素被默认初始化<br />函数不能改变预分配的内存空间大小 |
| `c.capacity()` | 返回容器`c`预分配的内存空间大小，表明了容器`c`在不重新分配内存空间情况下，最多能容纳的元素个数 |
| `c.reserve(n)` | 分配至少容纳`n`个元素的**内存空间**；这只是**分配建议**      |

- 只有没有操作需求超出`vector`的容量，`vector`就不能重新分配内存空间。
- 每次分配新内存空间时将当前容量翻倍。







