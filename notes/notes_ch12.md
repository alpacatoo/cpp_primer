# 第12章 动态内存

- 静态内存：保存局部static对象、类static数据成员、定义在任何函数之外的变量
- 栈内存：保存定义在函数内的非static对象；
- 保存在静态内存和栈内存中的对象由编译器自动创建和销毁
- 栈内存中的对象在其定义的程序块运行时才存在
- static对象在使用之前分配，程序结束时销毁
- **自由空间**或**堆**：用来存储动态分配的对象的内存空间



## 12.1 动态内存与智能指针

- 动态内存管理
  - 运算符**new**：在动态内存中为对象分配空间并返回一个指向该对象的指针
  - 运算符**delete**：接受一个动态对象的指针，销毁该对象，释放相关内存
- 标准库在**memory**头文件中定义的智能指针
  - 智能指针是模板，必须像`vector`一样提供额外信息；
  - 指针指针负责自动释放指向的对象
  - **shared_ptr**：允许多个指针指向同一个对象
  - **unique_ptr**：独占所指向的对象
  - **weak_ptr伴随类**：它是一个弱引用，指向`shared_ptr`所管理的对象

### 12.1.1 shared_ptr类

- `shared_ptr`和`unique_ptr`都支持的操作
  - 空智能指针，可以指向类型为`T`的对象：`shared_ptr<T> sp;`或者`unique_ptr<T> up`
  - 智能指针`p`用作一个条件潘顿，若`p`指向一个对象，则为`true`
  - 解引用智能指针`p`，即`*p`时，获得`p`指向的对象
  - `p->mem`等价于`(*p).mem`
  - 获得指针指针`p`中保存 指针：`p.get()`
  - 交换智能指针`p`和`q`中的指针
    - 算法函数方法：`swap(p, q)`
    - 成员函数方法：`p.swap(q)`
- `make_shared`函数分配对象并初始化
  - 在**memory**头文件中定义
  - `make_shared<T>(args)`
    - 返回一个`shared_ptr`，指向一个动态分配的类型为T的对象
    - 使用`args`作为T类型构造函数的输入，初始化对象
    - 当不传递任何`args`参数，对象会进行**值初始化**；即内置类型自动设置为0，类类型则由类默认初始化
- `shared_ptr`的拷贝与赋值
  - 每个`shared_ptr`有一个关联的引用计数。
  - 拷贝一个`shared_ptr`时，引用计数增加，具体包括
    - 用一个`shared_ptr`初始化另一个`shared_ptr`
    - 作为参数传递给一个函数
    - 作为函数的返回值
  - 引用计数递减情况
    - 给`shared_ptr`赋予一个新值
    - `shared_ptr`被销毁
  - 当引用计数变为0，则它会自动释放自己管理的对象
- `shared_ptr`自动销毁所管理的对象
  - 使用析构函数完成销毁的工作
  - 析构函数一般用来释放对象所分配的资源
- `shared_ptr`还会自动释放相关的内存
  - 如果智能指针`shared_ptr`被释放，且没有其他`shared_ptr`也指向这块内存，则会自动释放`shared_ptr`管理的动态内存
  - 如果将`shared_ptr`放在一个**容器**中，而后不再需要全部元素，而用其中一部分，要**记得`erase`删除不再需要的哪些元素**
- 使用动态内存的三个原因
  - 程序不知道自己需要使用多少对象——容器类
  - 程序不知道所需对象的准确类型——模板
  - 程序需要在多个对象间共享数据——智能指针

