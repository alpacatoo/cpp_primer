

## 练习4.1

> 表达式 5 + 10 * 20 / 2 的求值结果是多少？

105。

## 练习4.2

> 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
>
> * (a) *vec.begin()
> * (b) *vec.begin() + 1

```C++
*(vec.begin())
(*(vec.begin())) + 1
```

## 练习4.3

> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

可以接受。不同意个语句修改同一个对象。

C++的目的是效率最大化，因此相信程序员。

## 练习4.4

> 在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。
>
> 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2

((12/3)*4) + (5*15) + ((24%4)/2)

## 练习4.5

> 写出下列表达式的求值结果。

```C++
-30 * 3 + 21 / 5  // -90+4 = -86
-30 + 3 * 21 / 5  // -30+63/5 = -30+12 = -18
30 / 3 * 21 % 5   // 10*21%5 = 210%5 = 0
-30 / 3 * 21 % 4  // -10*21%4 = -210%4 = -2
```

## 练习4.6

> 写出一条表达式用于确定一个整数是奇数还是偶数。

```C++
if ( num % 2 == 0) /*...*/
```

## 练习4.7

> 溢出是何含义？写出三条将导致溢出的表达式。

数据超出表达范围

```C++
unsigned char a = 255; ++a; //0
signed char b = 127; ++b;//-128
unsigned char c = 0; --a; //255
```

## 练习4.8

> 说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。

* 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 **短路求值**。
* 相等性运算符未定义求值顺序。

## 练习4.9

> 解释在下面的if语句中条件部分的判断过程。
>
> ```C++
> const char *cp = "Hello World";
> if (cp && *cp)
> ```

首先判断 `cp` ，`cp` 不是一个空指针，因此 `cp` 为真。然后判断 `*cp`，`*cp` 的值是字符 'H'，非0。因此最后的结果为真。

## 练习4.10

> 为while 循环写一个条件，使其从标准输入中读取整数，遇到 42 时停止。

```C++
int i;
while(cin >> i && i != 42)
```

## 练习4.11

> 书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。

```C++
a>b && b>c && c>d
```

## 练习4.12

> 假设i、j 和k 是三个整数，说明表达式 i != j < k 的含义。

这个表达式等于 `i != (j < k)`。首先得到 j < k 的结果为 true 或 false，转换为整数值是 1 和 0，然后判断 i 不等于 1 和 0 ，最终的结果为 bool 值。

## 练习4.13

> 在下述语句中，当赋值完成后 i 和 d 的值分别是多少？
>
> ```C++
> int i;   double d;
> d = i = 3.5; 
> i = d = 3.5; 
> ```

第2行，i=3；d=3.0；第3行，d=3.5；i=3

## 练习4.14

> 执行下述 if 语句后将发生什么情况？
>
> ```C++
> if (42 = i)
> if (i = 42)
> ```

第1个if判读，编译器会报错；第2个if判断，一致为true

## 练习4.15

> 下面的赋值是非法的，为什么？应该如何修改？
>
> ```C++
> double dval; int ival; int *pi;
> dval = ival = pi = 0;
> ```

pi 是指针，不能赋值给 int ，应该改为：

```C++
dval = ival = 0;
pi = 0;
```

## 练习4.16

> 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
>
> ```C++
> if (p = getPtr() != 0)
> if (i = 1024)
> ```

条件判断总是为 true， 应该改为：

```cpp
if ((p=getPtr()) != 0)
if (i == 1024)
```

## 练习4.17

> 说明前置递增运算符和后置递增运算符的区别。

前置递增运算符将对象本身作为左值返回，而后置递增运算符将对象原始值的副本作为右值返回。

## 练习4.18

> 如果132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？

将会从第二个元素开始取值，并且最后对 v.end() 进行取值，结果是未定义的。

## 练习4.19

> 假设 ptr 的类型是指向 int 的指针、vec 的类型是vector<int>、ival 的类型是int，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？
>
> ```C++
> (a) ptr != 0 && *ptr++  
> (b) ival++ && ival
> (c) vec[ival++] <= vec[ival] 
> ```

（a）判断ptr 不是一个空指针，并且ptr 当前指向的元素的值也为真，然后将ptr指向下一个元素

（b）判断 ival 的值为真，并且 (ival + 1) 的值也为真

（c）表达式有误。C++并没有规定 `<=` 运算符两边的求值顺序，应该改为 `vec[ival] <= vec[ival+1]`