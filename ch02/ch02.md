# 变量和基本类型

## 2.1 基本内置类型

* C++基本数据类型
  * 算数类型（arithmetic type）
  * 空类型（void）

### 2.1.1 算术类型

* 算数类型分类：
  * 整型（intefral type），包括字符和布尔类型在内
  * 浮点型
* 布尔类型
  * 最小尺寸：未定义
  * 取值是真（true）或假（false）
* 字符类型
  * char类型：
    * 最小尺寸：8位
    * 确保可以存放机器基本字符集中任意字符对应的数字值
    * 一个char的大小与一个机器字节一致
  * wchar_t类型
    * 最新尺寸：16位
    * 确保可以存放机器扩展字符集中任意字符对应的数字值
  * char16_t类型
    * 最小尺寸：16位
    * 为Unicode字符集服务
  * char32_t类型
    * 最小尺寸：32位
    * 为Unicode字符集服务
* 整数类型
  * 最小尺寸：
    * shot：16位
    * int：16位
    * long：32位
    * long long：64位（C++11中定义）
  * 其他尺寸约束条件
    * int >= short
    * long >= int
    * long long >= long
* 浮点类型
  * float：1个字（32比特）表示，最小要求6位有效数字，一般有7位有效数字
  * double：2个字（64比特）表示，最小要求10位有效数字，一般16位有效数字
  * long double：3或4个字（96或128比特）表示，最小要求10位有效数字，不同实现具体精度不同
* 有符号类型和无符号类型
  * 除去布尔型和扩展的字符型之外，其他整型都可分为**带符号（signed）**和**无符号（unsigned）**
  * int、long、long long、short默认带符号，通过前缀unsgned定义无符号，例如unsinged long
  * unsigned int可简写为 unsigned
  * 字符型分为char、unsigned char、signed char
    * 两种表现形式：带符号和不带符号
    * 具体由编译器决定



### 2.1.2 类型转换
* 转换
| 源类型 | 目标类型 | 处理                     |
| ------ | -------- | ------------------------ |
| 非布尔 | 布尔     | 0表示false；非0表示true  |
| 布尔   | 非布尔   | false表示0；true表示1    |
| 浮点   | 整型     | 保留浮点数小数之前的部分 |
| 整数   | 浮点     | 小数部分记作0            |

* 无符号整型获得超出表示范围的数：数值取模后的余数
* 有符号整型获得超出表示范围的数：**未定义**
* 有符号负数转换成无符号：无符号数最大数值加有符号负数，再取模



### 2.1.3 字面值常量（literal）

* 整型字面值常量
  * 0开头整型代表8进制
  * 0x或0X开头整型代表十六进制
  * 十进制字面值默认是**带符号数**，且是int、long和long long中尺寸最小的
  * 十进制字面值不是负数，字符前的`-`符号表示取负数
* 浮点型字面值常量：表现未小数或以科学计数法表示的指数，指数部分用E或e表示
* 字符和字符串字面值
  * char型字面值：使用单引号括住
  * 字符串型字面值：使用双引号括住的0个或多个字符
  * 字符串实际是由常量字符构成的数组
  * 字符串结尾处由一个空字符（`\0`）
* 转义序列
  * 不能直接使用的字符：不可打印字符；特殊含义字符
  * 使用转义序列表示这些字符
  * 以`\`作为开始
  * 表示方法
    * 反斜线+字符表示一个功能；例如“\n”表示换行
    * 反斜线+八进制数表示；例如“\12”表示换行
    * \x+十六进制数表示；例如“\xA”表示换行
* 指定字面值类型
  * 字符和字符串字面值用前缀指定类型：u、U、L、u8分别对应类型char16_t、char32_t、wchar_t、char
  * 整型字面值用后缀
    * u or U最小匹配类型unsigned
    * l or L最小匹配long
    * ll or LL最小匹配long long
  * 浮点型字面值用后缀
    * f或F表示float
    * l或L表示long double
* 布尔字面值：true、false
* 指针字面值：nullptr



## 变量

* 变量提供一个具名的、可提供操作的存储空间
* 每个变量都有其数据类型
* C++来说，变量（variable）和对象（object）一般可以互换使用；
* 对象（object）是具有牟总数据类型的内存空间

### 变量定义

* 定义变量
  * 形式：类型说明符（tpe specifier） +  变量名 + 分号
  * 变量名可多个或一个，用逗号间隔
  * 例如：`int value1, value2;`
* 初始值
  * 初始化：任意**复杂表达式**初始化变量
  * 赋值和初始化不同
  * 例如：`double price = 109, discount = price * 0.16`，price是赋值，discount是初始化
* 列表初始化（list initialization）
  * 变量的初始化四种方法：
    * int units_solds = 0;
    * int units_solds = {0};
    * int units_solds{0};
    * int units_solds(0);
  * 使用花括号来初始化
  * 有点是当初始值存在丢失风险，编译器将报错
* 默认初始化（default initialization）
  * 函数体外定义的变量，默认初始化为0
  * 函数体内定义的变量，不被初始化（uninitialized）



### 2.2.2 变量声明和定义的关系

* C++支持分离式编译（separate compilation）机制，可以把程序分为多个文件独立编译
* 声明（declaration）使得名字为程序所知
* 定义（defination）负责创建与名字关联的实体
* 声明变量：使用extern关键字，并不显示地初始化变量
* extern关键定义的变量，显示地初始化了，这就变为定义



### 2.2.3 标识符（identifier）

* 对大小写敏感
* 规范：具有可读性；避免关键字相同

### 2.2.4 名字的作用域（scope）

* C++语言作用域都以花括号分隔
* main定义在所有花括号之外，具有全局作用域（global scope）
* 块作用域（block scope）
* 被包含的作用域称为内层作用域（inner scope）
* 包含作用域的作用域称为外层作用域（outer scope）



## 2.3 复合类型

- 复合类型（compound type）：指基于其他类型定义的类型
- 其中两种复合类型：引用和指针
- 声明语句：基本数据类型（base type） + 声明符（declarator）列表；
- 声明命名一个变量并指定该变量为其与基本数据类型有关的某种类型。
- 到目前为止，声明符其实就是变量名

### 2.3.1 引用
- 引用分为“右值引用”（rvalue reference）和“左值引用”（lvalue reference）；使用“引用”一词表示左值引用。
- 引用（reference）是为对象起另外一个名字。
- 通过将**声明符写成`&name`的形式**，其中name是声明的变量名。
- 引用将与初始值**绑定（bind）**在一起，必须初始化。
- 引用就是别名，并非对象，不能定义引用的引用
- 除了const引用、引用转换与继承，引用的类型都要和与之绑定的对象严格匹配。
- 引用的定义只能绑定对象，不能绑定**字面值**或**某个表达式的结算结果**
  ```C++
  int i = 1024;
  int &r = i;
  ```

### 2.3.2 指针
- 指针（pointer）指“指向（point to）”另外一种类型的复合类型。
- 指针本身是就是一个对象。
- 指针无需再定义时赋初值。
- 定义指针的**声明符使用`*d`的形式**，定义多个指针变量，每个变量前面都必须使用符号`*`
- 获取对象的地址：取地址符（操作符&）
- 除了const引用、引用转换与继承，所有指针的类型都要和它指向的对象严格匹配。
- 指针的值（即地址）的应该时4种状态之一：
  - 指向一个对象
  - 指向紧邻对象所占空间的下一个位置
  - 空指针，意味着指针没有指向任何对象
  - 无效指针，也就是上述情况之外的其他值
- 利用指针访问对象：解引用符（操作符`*`)
  ```C++
  int ival = 42;
  int *p = &ival;
  cout << *P;
  ```
- 空指针（null pointer）的表达形式
  - 直接赋值字面常量0，例如，`int p1 = 0`
  - 关键字nullptr，`int *p2 = nullptr;`等价于`int *p2 = 0;`
  - 宏定义NULL，需要包含头文件`cstdlib`，在预处理时刻给指针赋值
  - **不能将变量赋值给指针，即使变量的数值恰好等于0**
- 赋值和指针：指针和引用均提供其他对象的间接访问；通过等号左侧的对象弄清是改变了指针还是指针指向对象的值
- `void*`指针
  
  - 存放任意对象的地址；但不了解地址中是个什么类型的对象
  - 能做的事情：
    - 指针比较
    - 函数输入输出
    - 赋值给另一个`void*`指针
  - 不能做的事情：直接操作`void*`指向的对象

### 2.3.3 理解复合类型的声明
- 类型修饰符（`*`或和`&`）只是声明符的一部分，只作用于当前变量。

- 涉及指针和引用的声明的写法：
  - 方法一：强调变量具有的符合类型，类型符与变量标识符写在一起
    ```C++
    int *p1, *p2;
    ```
  - 方法二：强调本次声明定义了一种符合类型；类型修饰符与类型名写一起，并且每条语句只定义一个变量
    ```C++
    int* p1;
    int* p2;
    ```
- 指向指针的指针
  - 声明符中的类型修饰符个数没有限制
  - 通过`*`的个数，却分指针的级别；`**`表示指向指针的指针；`***`表示指向指针的指针的指针
- 指向指针的引用
  - 引用本身不是对象，不能定义指向引用的指针
  - 从右向左阅读变量的定义；离变量名最近的符号对变量的类型有最直接的影响
    ```C++
    int i = 42;
    int *p;			//p是一个int型指针
    int *&r = p; 	//r是一个对指针p的引用
    r=&i;			//r引用了一个指针，因此给r赋值&i就是令p指向i
    *r = 0;			//解引用r得到i，也就是p指向的对象，将i的值改为0
    ```



## 2.4 const限定符

- 只能在const类型的对象上执行不改变其内容的操作。

- const对象必须初始化，这是一种不改变const对象的操作之一

- 拷贝操作不改变源变量，可以用const变量初始化其他变量。

- const对象在编译阶段被替换成数值常量

- const对象的作用域限定在本文件内

- 为了在多个文件中使用同一个文件，在定义与声明const对象时候，均使用extern关键字

  ```C++
  extern const int bufSize = fcn();	//在cpp文件中定义
  extern const int bufSize;			//在hpp文件中声明，指明bufSize并非本文件所独有
  ```

### 2.4.1 const的引用
- **对常量的引用（reference to const）**不能被用作修改它所绑定的对象
  ```C++
  const int c = 1024;
  const int &r1 = ci;	//正确：引用及其对应的对象都是常量
  r1 = 42;			//错误：r1是对常量的引用
  int &r2 = ci;		//错误：试图让一个非常量的引用指向一个常量
  ```
- 初始化**常量引用**时允许绑定非常量的对象、字面值。甚至任意表达式；
- 引用类型必须与其引用对象的类型可以不一致；此时绑定在一个**临时量（temporary）**
- 常量引用不对引用对象做限定；不能通过引用修改非常量对象，但可以通过其他途径修改非常量对象

### 2.4.2 指针和const
- **指向常量的指针（Pointer to const）**不能用于改变其所指对象的值；没有规定指向的对象不能通过其他途径改变
- 存放常量对象的地址，只能使用指向常量的指针；
- 允许指向常量的指针指向非常量对象；
- **常量指针（const pointer）**必须初始化；将`*`放在const关键字之前用以说明指针是常量

### 2.4.3 顶层const
- 顶层const（top-level const）：表示指针本身是个常量
- 底层const（low-level const）：表示指针所指的对象是常量
- 顶层const可以表示任意对象是常量；
- 底层const与指针和引用等符合类型的基本类型部分有关；
- 指针类型既可以是顶层const也可以是底层const
- 拷贝需要有相同的底层const

### 2.4.4 constexpr和常量表达式
- 常量表达式（const expression）值不会改变，并且在**编译过程**就能得到计算结果的表达式。
- 通过constexpr关键字以便编译器验证变量的值是否是也给常量表达式，必须用常量表达式初始化。
- 字面值类型可以声明constexpr，包括算数类型、指针和引用。
- constexpr指针的初始值必须是nullptr或0，或者存储于某个固定地址中的对象；constexpr支队指针有效，对所指对象无效。
- constexpr关键字把所定义的对象置为了顶层const



## 2.5 处理类型

### 2.5.1 类型别名（type alias）

- **typedef关键字**定义类型别名

  ```C++
  typedef double wages;	//wages是double的同义词
  typedef wages base, *p;	//base是double的同义词，p是double*的同义词
  ```

- **别名声明（alias eclaration）**定义类型的别名

  ```C++
  using SI = Sales_items; 	//SI是Sales_items的同义词
  ```

- const修饰基本数据类型，类型别名改变了基本数据类型

  ```C++
  typedef char *pstring;
  const pstring csstr = 0;	//cstr是指向char的常量指针，由于别面，基础类型变成是指针，如果替换就改变基础类型为char
  consst pstring *ps			//ps是一个指针，它的对象是指向char的常量指针
  ```

### 2.5.2 auto类型说明符

- **auto**类型说明符，能让编译器体我们取分析**表达式的值**所属的类型
- **auto**定义的变量必须有初始值
- 一个声明中可以有多个变量，但基本类型必须一致（以第一个变量为准）
- 引用其实是使用引用对象的值进行初始化
- auto会忽略顶层const，底层const则会保留
- auto若要推断顶层const，需要显示的指出
- auto引用会保留顶层const

### 2.5.3 decltype类型说明符

- 从表达式推断出类型，返回操作数的数据类型

- decltype处理顶层const和引用的方式于auto有些不同。

  - 变量返回变量的类型

  - 引用返回引用类型（**引用作为其引用对象同义词出现的一个例外**）

    ```C++
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0;	//x为const int类型
    decltype(cj) y = x;	//y为const int &类型
    ```

- `r`是引用，则`decltype(r)`推断为引用类型；为了推断出r所指的类型，则`decltype(r+0)`通过表达式的结果值

- 表达式的结果是解引用，则推断都引用类型。

- `decltype((variable))`的结果永远是引用。

### 2.5.4 自定义数据结构

- struct关键字，加括号，括号后面必须有分号。
- 

